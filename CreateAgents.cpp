//
//  CreateAgents.cpp
// 
//
//  Created by L. Dombrowski on 1/21/20
//

#include "CreateAgents.h"
#include "GlobalParameters.h"
#include "FGlobal.h"
#include "InputChange.h"

using namespace std;



// generate a random number using mt19937 marisenne twister algorithm
// find next number in sequence - will get slower the longer it runs
int getRandomNo( int nextNo, uniform_int_distribution<int> r1, std::mt19937 generator) {

    // everytime routine is called, it starts back at the beginning of sequence
    // need to run through n times to get the n+1 number
    int randInt = 0;
    
    for(int i = 0; i < nextNo+1; i++) {
    
        randInt = r1(generator);
    }

    return randInt;
    
}

// generate a random number from a list generated by mt19937 marisenne twister algorithm
int getNextRandomNo100() {

    int randInt = 0;
    
    randInt = seq100[nextNoSeq100];
    
    // increment sequence index
    nextNoSeq100++;

    return randInt;
    
}

// generate a random number from a list generated by mt19937 marisenne twister algorithm
int getNextRandomNoPop(string disease) {

    //std::cout << "getNextRandomNoPop disease =  " << disease << "\n";
    
    int randInt = 0;
    
    if (disease == "TB") {
    
        randInt = seqPopTB[nextNoSeqPopTB];
    
        // increment sequence index
        nextNoSeqPopTB++;
    }
    else if (disease == "HIV") {
    
        randInt = seqPopHIV[nextNoSeqPopHIV];
    
        // increment sequence index
        nextNoSeqPopHIV++;
    }
    else if (disease == "HCV") {
    
        randInt = seqPopHCV[nextNoSeqPopHCV];
    
        // increment sequence index
        nextNoSeqPopHCV++;
    }
    else if (disease == "Yellow Fever") {
    
        randInt = seqPopYF[nextNoSeqPopYF];
    
        // increment sequence index
        nextNoSeqPopYF++;
    }
    else if (disease == "Meningitis") {
    
        randInt = seqPopMen[nextNoSeqPopMen];
    
        // increment sequence index
        nextNoSeqPopMen++;

        //std::cout << "next meningitis random number " << randInt << "\n";
    }
    else if (disease == "Measles") {
    
        randInt = seqPopMea[nextNoSeqPopMea];
    
        // increment sequence index
        nextNoSeqPopMea++;
    }
    else if (disease == "Disease1") {

        randInt = seqPopDis1[nextNoSeqPopDis1];

        // increment sequence index
        nextNoSeqPopDis1++;
    }
    else if (disease == "Disease2") {

        randInt = seqPopDis2[nextNoSeqPopDis2];

        // increment sequence index
        nextNoSeqPopDis2++;
    }

    return randInt;
    
}

// generate a random exponential number from a list
//int getNextRandomExpNo() {
//
//    int randInt = 0;
//
//    randInt = expSeq[nextNoExpSeq];
//
//    // increment sequence index
//    nextNoExpSeq++;
//
//    return randInt;
//
//}

// generate a random geometric number from a list
int getNextRandomGeoNo() {

    int randInt = 0;

    randInt = geoSeq[nextNoGeoSeq];

    // increment sequence index
    nextNoGeoSeq++;

    return randInt;

}



// find the tier associated with facility type - each country may have it's own mapping
int findTier(string type) {

    // default to top level
    int tier = 1;

    if (type == tier1Mapping)
        tier = 1;
    if (type == tier2Mapping)
        tier = 2;
    if (type == tier3aMapping)
        tier = 3;
    if (type == tier3bMapping)
        tier = 3;
    if (type == tier4aMapping)
        tier = 4;
    if (type == tier4bMapping)
        tier = 4;
    if (type == tier4cMapping)
        tier = 4;
    if (type == tier4dMapping)
        tier = 4;
    if (type == tier5aMapping)
        tier = 5;
    if (type == tier5bMapping)
        tier = 5;   
    if (type == tier5cMapping)
        tier = 5;
    if (type == tier6Mapping)
        tier = 6;
    if (type == tier7aMapping)
        tier = 7;
    if (type == tier7bMapping)
        tier = 7;
    // std::cout << "find Tier " << type << ", " << tier << "\n";

    return tier;

}

// find whether there is testing associated with a tier - each country may have it's own mapping
bool findTestingAvailable(int tier, string disease, string test) {

    //std::cout << "inside findTestingAvaialbe " << disease << ", " << test << "\n";

    if (disease == "TB") {

        if (test == "Xpert") {
            switch (tier) {
            case 1:
                return tier1TBTestingXpert;
                break;
            case 2:
                return tier2TBTestingXpert;
                break;
            case 3:
                return tier3TBTestingXpert;
                break;
            case 4:
                return tier4TBTestingXpert;
                break;
            case 5:
                return tier5TBTestingXpert;
                break;
            case 6:
                return tier6TBTestingXpert;
                break;
            case 7:
                return tier7TBTestingXpert;
                break;
            case 8:
                return tier8TBTestingXpert;
                break;
            case 9:
                return tier9TBTestingXpert;
                break;
            case 10:
                return tier10TBTestingXpert;
                break;
            default:
                return false;
            }
        }
        else if (test == "smear") {
            switch (tier) {
            case 1:
                return tier1TBTestingSmear;
                break;
            case 2:
                return tier2TBTestingSmear;
                break;
            case 3:
                return tier3TBTestingSmear;
                break;
            case 4:
                return tier4TBTestingSmear;
                break;
            case 5:
                return tier5TBTestingSmear;
                break;
            case 6:
                return tier6TBTestingSmear;
                break;
            case 7:
                return tier7TBTestingSmear;
                break;
            case 8:
                return tier8TBTestingSmear;
                break;
            case 9:
                return tier9TBTestingSmear;
                break;
            case 10:
                return tier10TBTestingSmear;
                break;
            default:
                return false;
            }
        }
    }
    else if (disease == "HIV") {
        switch (tier) {
        case 1:
            return tier1HIVTestingXpert;
            break;
        case 2:
            return tier2HIVTestingXpert;
            break;
        case 3:
            return tier3HIVTestingXpert;
            break;
        case 4:
            return tier4HIVTestingXpert;
            break;
        case 5:
            return tier5HIVTestingXpert;
            break;
        case 6:
            return tier6HIVTestingXpert;
            break;
        case 7:
            return tier7HIVTestingXpert;
            break;
        case 8:
            return tier8HIVTestingXpert;
            break;
        case 9:
            return tier9HIVTestingXpert;
            break;
        case 10:
            return tier10HIVTestingXpert;
            break;
        default:
            return false;
        }
    } 
    else if (disease == "HCV") {
        switch (tier) {
        case 1:
            return tier1HCVTestingXpert;
            break;
        case 2:
            return tier2HCVTestingXpert;
            break;
        case 3:
            return tier3HCVTestingXpert;
            break;
        case 4:
            return tier4HCVTestingXpert;
            break;
        case 5:
            return tier5HCVTestingXpert;
            break;
        case 6:
            return tier6HCVTestingXpert;
            break;
        case 7:
            return tier7HCVTestingXpert;
            break;
        case 8:
            return tier8HCVTestingXpert;
            break;
        case 9:
            return tier9HCVTestingXpert;
            break;
        case 10:
            return tier10HCVTestingXpert;
            break;
        default:
            return false;
        }
    } 
    else if (disease == "YF") {
        switch (tier) {
        case 1:
            return tier1YFTestingXpert;
            break;
        case 2:
            return tier2YFTestingXpert;
            break;
        case 3:
            return tier3YFTestingXpert;
            break;
        case 4:
            return tier4YFTestingXpert;
            break;
        case 5:
            return tier5YFTestingXpert;
            break;
        case 6:
            return tier6YFTestingXpert;
            break;
        case 7:
            return tier7YFTestingXpert;
            break;
        case 8:
            return tier8YFTestingXpert;
            break;
        case 9:
            return tier9YFTestingXpert;
            break;
        case 10:
            return tier10YFTestingXpert;
            break;
        default:
            return false;
        }
    }
    else if (disease == "Meningitis") {
        switch (tier) {
        case 1:
            return tier1MenTestingPCR;
            break;
        case 2:
            return tier2MenTestingPCR;
            break;
        case 3:
            return tier3MenTestingPCR;
            break;
        case 4:
            return tier4MenTestingPCR;
            break;
        case 5:
            return tier5MenTestingPCR;
            break;
        case 6:
            return tier6MenTestingPCR;
            break;
        case 7:
            return tier7MenTestingPCR;
            break;
        case 8:
            return tier8MenTestingPCR;
            break;
        case 9:
            return tier9MenTestingPCR;
            break;
        case 10:
            return tier10MenTestingPCR;
            break;
        default:
            return false;
        }
    }
    else if (disease == "Measles") {
        switch (tier) {
        case 1:
            return tier1MeaTestingCulture;
            break;
        case 2:
            return tier2MeaTestingCulture;
            break;
        case 3:
            return tier3MeaTestingCulture;
            break;
        case 4:
            return tier4MeaTestingCulture;
            break;
        case 5:
            return tier5MeaTestingCulture;
            break;
        case 6:
            return tier6MeaTestingCulture;
            break;
        case 7:
            return tier7MeaTestingCulture;
            break;
        case 8:
            return tier8MeaTestingCulture;
            break;
        case 9:
            return tier9MeaTestingCulture;
            break;
        case 10:
            return tier10MeaTestingCulture;
            break;
        default:
            return false;
        }
    }
    else if (disease == "Disease1") {
        switch (tier) {
        case 1:
            return tier1Dis1TestingTest;
            break;
        case 2:
            return tier2Dis1TestingTest;
            break;
        case 3:
            return tier3Dis1TestingTest;
            break;
        case 4:
            return tier4Dis1TestingTest;
            break;
        case 5:
            return tier5Dis1TestingTest;
            break;
        case 6:
            return tier6Dis1TestingTest;
            break;
        case 7:
            return tier7Dis1TestingTest;
            break;
        case 8:
            return tier8Dis1TestingTest;
            break;
        case 9:
            return tier9Dis1TestingTest;
            break;
        case 10:
            return tier10Dis1TestingTest;
            break;
        default:
            return false;
        }
    }
    else if (disease == "Disease2") {
        switch (tier) {
        case 1:
            return tier1Dis2TestingTest;
            break;
        case 2:
            return tier2Dis2TestingTest;
            break;
        case 3:
            return tier3Dis2TestingTest;
            break;
        case 4:
            return tier4Dis2TestingTest;
            break;
        case 5:
            return tier5Dis2TestingTest;
            break;
        case 6:
            return tier6Dis2TestingTest;
            break;
        case 7:
            return tier7Dis2TestingTest;
            break;
        case 8:
            return tier8Dis2TestingTest;
            break;
        case 9:
            return tier9Dis2TestingTest;
            break;
        case 10:
            return tier10Dis2TestingTest;
            break;
        default:
            return false;
        }
    }

    return false;
}

// find whether there is testing associated with a tier - each country may have it's own mapping
void  findTestingAvailable(int tier, vector <testingAvailableAttr*> testing) {

    // store away testing available flags with disease they are associated with in structure array
    int i = 0;

    for (auto t: testing) {

        // assume test is Xpert unless explicitly stated
        t->testName = "Xpert";

        if (i == 0) {
        
            t->disease = "TB";

            switch (tier) {
            case 1:
               t->testing = tier1TBTestingXpert;
                break;
            case 2:
                t->testing = tier2TBTestingXpert;
                break;
            case 3:
                t->testing = tier3TBTestingXpert;
                break;
            case 4:
                t->testing = tier4TBTestingXpert;
                break;
            case 5:
                t->testing = tier5TBTestingXpert;
                break;
            case 6:
                t->testing = tier6TBTestingXpert;
                break;
            case 7:
                t->testing = tier7TBTestingXpert;
                break;
            case 8:
                t->testing = tier8TBTestingXpert;
                break;
            case 9:
                t->testing = tier9TBTestingXpert;
                break;
            case 10:
                t->testing = tier10TBTestingXpert;
                break;
            default:
                t->testing = false;
            }
        }
        else if (i == 1) {
        
            t->disease = "TB";
            t->testName = "smear";

            switch (tier) {
            case 1:
               t->testing = tier1TBTestingSmear;
                break;
            case 2:
                t->testing = tier2TBTestingSmear;
                break;
            case 3:
                t->testing = tier3TBTestingSmear;
                break;
            case 4:
                t->testing = tier4TBTestingSmear;
                break;
            case 5:
                t->testing = tier5TBTestingSmear;
                break;
            case 6:
                t->testing = tier6TBTestingSmear;
                break;
            case 7:
                t->testing = tier7TBTestingSmear;
                break;
            case 8:
                t->testing = tier8TBTestingSmear;
                break;
            case 9:
                t->testing = tier9TBTestingSmear;
                break;
            case 10:
                t->testing = tier10TBTestingSmear;
                break;
            default:
                t->testing = false;
            }
        }
        else if (i == 2) {
            t->disease = "HIV";

            switch (tier) {
            case 1:
                t->testing = tier1HIVTestingXpert;
                break;
            case 2:
                t->testing = tier2HIVTestingXpert;
                break;
            case 3:
                t->testing = tier3HIVTestingXpert;
                break;
            case 4:
                t->testing = tier4HIVTestingXpert;
                break;
            case 5:
                t->testing = tier5HIVTestingXpert;
                break;
            case 6:
                t->testing = tier6HIVTestingXpert;
                break;
            case 7:
                t->testing = tier7HIVTestingXpert;
                break;
            case 8:
                t->testing = tier8HIVTestingXpert;
                break;
            case 9:
                t->testing = tier9HIVTestingXpert;
                break;
            case 10:
                t->testing = tier10HIVTestingXpert;
                break;
            default:
                t->testing = false;
            }
        }
        else if (i == 3) {
            t->disease = "HCV";

            switch (tier) {
            case 1:
                t->testing = tier1HCVTestingXpert;
                break;
            case 2:
                t->testing = tier2HCVTestingXpert;
                break;
            case 3:
                t->testing = tier3HCVTestingXpert;
                break;
            case 4:
                t->testing = tier4HCVTestingXpert;
                break;
            case 5:
                t->testing = tier5HCVTestingXpert;
                break;
            case 6:
                t->testing= tier6HCVTestingXpert;
                break;
            case 7:
                t->testing = tier7HCVTestingXpert;
                break;
            case 8:
                t->testing = tier8HCVTestingXpert;
                break;
            case 9:
                t->testing = tier9HCVTestingXpert;
                break;
            case 10:
                t->testing = tier10HCVTestingXpert;
                break;
            default:
                t->testing = false;
            }
        }
        else if (i == 4) {
            t->disease = "YF";

            switch (tier) {
            case 1:
                t->testing = tier1YFTestingXpert;
                break;
            case 2:
                t->testing = tier2YFTestingXpert;
                break;
            case 3:
                t->testing = tier3YFTestingXpert;
                break;
            case 4:
                t->testing = tier4YFTestingXpert;
                break;
            case 5:
                t->testing = tier5YFTestingXpert;
                break;
            case 6:
                t->testing = tier6YFTestingXpert;
                break;
            case 7:
                t->testing = tier7YFTestingXpert;
                break;
            case 8:
                t->testing = tier8YFTestingXpert;
                break;
            case 9:
                t->testing = tier9YFTestingXpert;
                break;
            case 10:
                t->testing = tier10YFTestingXpert;
                break;
            default:
                t->testing = false;
            }
        }
        else if (i == 5) {
            t->disease = "Meningitis";
             t->testName = "PCR";

            switch (tier) {
            case 1:
                t->testing = tier1MenTestingPCR;
                break;
            case 2:
                t->testing = tier2MenTestingPCR;
                break;
            case 3:
                t->testing = tier3MenTestingPCR;
                break;
            case 4:
                t->testing = tier4MenTestingPCR;
                break;
            case 5:
                t->testing = tier5MenTestingPCR;
                break;
            case 6:
                t->testing = tier6MenTestingPCR;
                break;
            case 7:
                t->testing = tier7MenTestingPCR;
                break;
            case 8:
                t->testing = tier8MenTestingPCR;
                break;
            case 9:
                t->testing = tier9MenTestingPCR;
                break;
            case 10:
                t->testing= tier10MenTestingPCR;
                break;
            default:
                t->testing = false;
            }
        }
        else if (i == 6) {
            t->disease = "Measles";
            t->testName = "culture";

            switch (tier) {
            case 1:
                t->testing = tier1MeaTestingCulture;
                break;
            case 2:
                t->testing = tier2MeaTestingCulture;
                break;
            case 3:
                t->testing = tier3MeaTestingCulture;
                break;
            case 4:
                t->testing = tier4MeaTestingCulture;
                break;
            case 5:
                t->testing = tier5MeaTestingCulture;
                break;
            case 6:
                t->testing = tier6MeaTestingCulture;
                break;
            case 7:
                t->testing = tier7MeaTestingCulture;
                break;
            case 8:
                t->testing = tier8MeaTestingCulture;
                break;
            case 9:
                t->testing = tier9MeaTestingCulture;
                break;
            case 10:
                t->testing = tier10MeaTestingCulture;
                break;
            default:
                t->testing = false;
            }
        }
        else if (i == 7) {
            t->disease = "Disease1";
            t->testName = "Test";

            switch (tier) {
            case 1:
                t->testing = tier1Dis1TestingTest;
                break;
            case 2:
                t->testing = tier2Dis1TestingTest;
                break;
            case 3:
                t->testing = tier3Dis1TestingTest;
                break;
            case 4:
                t->testing = tier4Dis1TestingTest;
                break;
            case 5:
                t->testing = tier5Dis1TestingTest;
                break;
            case 6:
                t->testing = tier6Dis1TestingTest;
                break;
            case 7:
                t->testing = tier7Dis1TestingTest;
                break;
            case 8:
                t->testing = tier8Dis1TestingTest;
                break;
            case 9:
                t->testing = tier9Dis1TestingTest;
                break;
            case 10:
                t->testing = tier10Dis1TestingTest;
                break;
            default:
                t->testing = false;
            }
        }
        else if (i == 8) {
            t->disease = "Disease2";
            t->testName = "Test";

            switch (tier) {
            case 1:
                t->testing = tier1Dis2TestingTest;
                break;
            case 2:
                t->testing = tier2Dis2TestingTest;
                break;
            case 3:
                t->testing = tier3Dis2TestingTest;
                break;
            case 4:
                t->testing = tier4Dis2TestingTest;
                break;
            case 5:
                t->testing = tier5Dis2TestingTest;
                break;
            case 6:
                t->testing = tier6Dis2TestingTest;
                break;
            case 7:
                t->testing = tier7Dis2TestingTest;
                break;
            case 8:
                t->testing = tier8Dis2TestingTest;
                break;
            case 9:
                t->testing = tier9Dis2TestingTest;
                break;
            case 10:
                t->testing = tier10Dis2TestingTest;
                break;
            default:
                t->testing = false;
            }
        }


       i = i+1;
    }
       
}

//create testing available structure vector associated with a tier - each country may have it's own mapping
vector <testingAvailableAttr*> createTestingAvailableByTier(int tier) {

    
    vector<testingAvailableAttr*> testingAvailablePtr;

    // store away testing available flags with disease they are associated with in structure array
    testingAvailableAttr* testingAttr = new testingAvailableAttr;

    testingAttr->disease = "TB";
    testingAttr->testName = "Xpert";
                       
    switch (tier) {
        case 1:
            testingAttr->testing = tier1TBTestingXpert;
            break;
        case 2:
            testingAttr->testing = tier2TBTestingXpert;
            break;
        case 3:
            testingAttr->testing = tier3TBTestingXpert;
            break;
        case 4:
            testingAttr->testing = tier4TBTestingXpert;
            break;
        case 5:
            testingAttr->testing = tier5TBTestingXpert;
            break;
        case 6:
            testingAttr->testing = tier6TBTestingXpert;
            break;
        case 7:
            testingAttr->testing = tier7TBTestingXpert;
            break;
        case 8:
            testingAttr->testing = tier8TBTestingXpert;
            break;
        case 9:
            testingAttr->testing = tier9TBTestingXpert;
            break;
        case 10:
            testingAttr->testing = tier10TBTestingXpert;
            break;
        default:
            testingAttr->testing = false;
    }

    testingAvailablePtr.push_back(testingAttr);

    testingAvailableAttr* testingAttr1 = new testingAvailableAttr;

    testingAttr1->disease = "TB";
    testingAttr1->testName = "smear";
                       
    switch (tier) {
        case 1:
            testingAttr1->testing = tier1TBTestingSmear;
            break;
        case 2:
            testingAttr1->testing = tier2TBTestingSmear;
            break;
        case 3:
            testingAttr1->testing = tier3TBTestingSmear;
            break;
        case 4:
            testingAttr1->testing = tier4TBTestingSmear;
            break;
        case 5:
            testingAttr1->testing = tier5TBTestingSmear;
            break;
        case 6:
            testingAttr1->testing = tier6TBTestingSmear;
            break;
        case 7:
            testingAttr1->testing = tier7TBTestingSmear;
            break;
        case 8:
            testingAttr1->testing = tier8TBTestingSmear;
            break;
        case 9:
            testingAttr1->testing = tier9TBTestingSmear;
            break;
        case 10:
            testingAttr1->testing = tier10TBTestingSmear;
            break;
        default:
            testingAttr1->testing = false;
    }

    testingAvailablePtr.push_back(testingAttr1);

    testingAvailableAttr* testingAttr2 = new testingAvailableAttr;

    testingAttr2->disease = "HIV";
    testingAttr2->testName = "Xpert";
                       
    switch (tier) {
        case 1:
            testingAttr2->testing = tier1HIVTestingXpert;
            break;
        case 2:
            testingAttr2->testing = tier2HIVTestingXpert;
            break;
        case 3:
            testingAttr2->testing = tier3HIVTestingXpert;
            break;
        case 4:
            testingAttr2->testing = tier4HIVTestingXpert;
            break;
        case 5:
            testingAttr2->testing = tier5HIVTestingXpert;
            break;
        case 6:
            testingAttr2->testing = tier6HIVTestingXpert;
            break;
        case 7:
            testingAttr2->testing = tier7HIVTestingXpert;
            break;
        case 8:
            testingAttr2->testing = tier8HIVTestingXpert;
            break;
        case 9:
            testingAttr2->testing = tier9HIVTestingXpert;
            break;
        case 10:
            testingAttr2->testing = tier10HIVTestingXpert;
            break;
        default:
            testingAttr2->testing = false;
    }

    testingAvailablePtr.push_back(testingAttr2);
        
    
    testingAvailableAttr* testingAttr3 = new testingAvailableAttr;

    testingAttr3->disease = "HCV";
    testingAttr3->testName = "Xpert";
                       
    switch (tier) {
        case 1:
            testingAttr3->testing = tier1HCVTestingXpert;
            break;
        case 2:
            testingAttr3->testing = tier2HCVTestingXpert;
            break;
        case 3:
            testingAttr3->testing = tier3HCVTestingXpert;
            break;
        case 4:
            testingAttr3->testing = tier4HCVTestingXpert;
            break;
        case 5:
            testingAttr3->testing = tier5HCVTestingXpert;
            break;
        case 6:
            testingAttr3->testing = tier6HCVTestingXpert;
            break;
        case 7:
            testingAttr3->testing = tier7HCVTestingXpert;
            break;
        case 8:
            testingAttr3->testing = tier8HCVTestingXpert;
            break;
        case 9:
            testingAttr3->testing = tier9HCVTestingXpert;
            break;
        case 10:
            testingAttr3->testing = tier10HCVTestingXpert;
            break;
        default:
            testingAttr3->testing = false;
    }

    testingAvailablePtr.push_back(testingAttr3);
        
    testingAvailableAttr* testingAttr4 = new testingAvailableAttr;

    testingAttr4->disease = "Yellow Fever";
    testingAttr4->testName = "Xpert";
                       
    switch (tier) {
        case 1:
            testingAttr4->testing = tier1YFTestingXpert;
            break;
        case 2:
            testingAttr4->testing = tier2YFTestingXpert;
            break;
        case 3:
            testingAttr4->testing = tier3YFTestingXpert;
            break;
        case 4:
            testingAttr4->testing = tier4YFTestingXpert;
            break;
        case 5:
            testingAttr4->testing = tier5YFTestingXpert;
            break;
        case 6:
            testingAttr4->testing = tier6YFTestingXpert;
            break;
        case 7:
            testingAttr4->testing = tier7YFTestingXpert;
            break;
        case 8:
            testingAttr4->testing = tier8YFTestingXpert;
            break;
        case 9:
            testingAttr4->testing = tier9YFTestingXpert;
            break;
        case 10:
            testingAttr4->testing = tier10YFTestingXpert;
            break;
        default:
            testingAttr4->testing = false;
    }

    testingAvailablePtr.push_back(testingAttr4);
             
    testingAvailableAttr* testingAttr5 = new testingAvailableAttr;

    testingAttr5->disease = "Meningitis";
    testingAttr5->testName = "PCR";
                       
    switch (tier) {
        case 1:
            testingAttr5->testing = tier1MenTestingPCR;
            break;
        case 2:
            testingAttr5->testing = tier2MenTestingPCR;
            break;
        case 3:
            testingAttr5->testing = tier3MenTestingPCR;
            break;
        case 4:
            testingAttr5->testing = tier4MenTestingPCR;
            break;
        case 5:
            testingAttr5->testing = tier5MenTestingPCR;
            break;
        case 6:
            testingAttr5->testing = tier6MenTestingPCR;
            break;
        case 7:
            testingAttr5->testing = tier7MenTestingPCR;
            break;
        case 8:
            testingAttr5->testing = tier8MenTestingPCR;
            break;
        case 9:
            testingAttr5->testing = tier9MenTestingPCR;
            break;
        case 10:
            testingAttr5->testing = tier10MenTestingPCR;
            break;
        default:
            testingAttr5->testing = false;
    }

    testingAvailablePtr.push_back(testingAttr5);

    testingAvailableAttr* testingAttr6 = new testingAvailableAttr;

    testingAttr6->disease = "Measles";
    testingAttr6->testName = "culture";
                       
    switch (tier) {
        case 1:
            testingAttr6->testing = tier1MeaTestingCulture;
            break;
        case 2:
            testingAttr6->testing = tier2MeaTestingCulture;
            break;
        case 3:
            testingAttr6->testing = tier3MeaTestingCulture;
            break;
        case 4:
            testingAttr6->testing = tier4MeaTestingCulture;
            break;
        case 5:
            testingAttr6->testing = tier5MeaTestingCulture;
            break;
        case 6:
            testingAttr6->testing = tier6MeaTestingCulture;
            break;
        case 7:
            testingAttr6->testing = tier7MeaTestingCulture;
            break;
        case 8:
            testingAttr6->testing = tier8MeaTestingCulture;
            break;
        case 9:
            testingAttr6->testing = tier9MeaTestingCulture;
            break;
        case 10:
            testingAttr6->testing = tier10MeaTestingCulture;
            break;
        default:
            testingAttr6->testing = false;
    }

    testingAvailablePtr.push_back(testingAttr6);


    testingAvailableAttr* testingAttr7 = new testingAvailableAttr;

    testingAttr7->disease = "Disease1";
    testingAttr7->testName = "Test";

    switch (tier) {
        case 1:
            testingAttr7->testing = tier1Dis1TestingTest;
            break;
        case 2:
            testingAttr7->testing = tier2Dis1TestingTest;
            break;
        case 3:
            testingAttr7->testing = tier3Dis1TestingTest;
            break;
        case 4:
            testingAttr7->testing = tier4Dis1TestingTest;
            break;
        case 5:
            testingAttr7->testing = tier5Dis1TestingTest;
            break;
        case 6:
            testingAttr7->testing = tier6Dis1TestingTest;
            break;
        case 7:
            testingAttr7->testing = tier7Dis1TestingTest;
            break;
        case 8:
            testingAttr7->testing = tier8Dis1TestingTest;
            break;
        case 9:
            testingAttr7->testing = tier9Dis1TestingTest;
            break;
        case 10:
            testingAttr7->testing = tier10Dis1TestingTest;
            break;
        default:
            testingAttr7->testing = false;
    }

    testingAvailablePtr.push_back(testingAttr7);

    testingAvailableAttr* testingAttr8 = new testingAvailableAttr;

    testingAttr8->disease = "Disease2";
    testingAttr8->testName = "Test";

    switch (tier) {
        case 1:
            testingAttr8->testing = tier1Dis2TestingTest;
            break;
        case 2:
            testingAttr8->testing = tier2Dis2TestingTest;
            break;
        case 3:
            testingAttr8->testing = tier3Dis2TestingTest;
            break;
        case 4:
            testingAttr8->testing = tier4Dis2TestingTest;
            break;
        case 5:
            testingAttr8->testing = tier5Dis2TestingTest;
            break;
        case 6:
            testingAttr8->testing = tier6Dis2TestingTest;
            break;
        case 7:
            testingAttr8->testing = tier7Dis2TestingTest;
            break;
        case 8:
            testingAttr8->testing = tier8Dis2TestingTest;
            break;
        case 9:
            testingAttr8->testing = tier9Dis2TestingTest;
            break;
        case 10:
            testingAttr8->testing = tier10Dis2TestingTest;
            break;
        default:
            testingAttr8->testing = false;
    }

    testingAvailablePtr.push_back(testingAttr8);


           
       return testingAvailablePtr;
}

// find whether there is diagnosis associated with a tier - each country may have it's own mapping
bool findDiagnosisAvailable(int tier) {
    switch (tier) {
    case 1:
        return tier1Diagnosis;
    case 2:
        return tier2Diagnosis;
    case 3:
        return tier3Diagnosis;
    case 4:
        return tier4Diagnosis;
    case 5:
        return tier5Diagnosis;
    case 6:
        return tier6Diagnosis;
    case 7:
        return tier7Diagnosis;
    case 8:
        return tier8Diagnosis;
    case 9:
        return tier9Diagnosis;
    case 10:
        return tier10Diagnosis;
    default:
        return false;
    }
}





void dumpFacilityAttributes(FacilitiesList* list) {

   string facName;
   bool debugFlag = true;
   vector<facilityAttributes*> facAttr;
   // facilityAttributes
   /*string disease;
   string testName;
   bool testing;
   int priority;
   float incidence;
   string incAdjType;
   float incAdjFactor;
   float prpIncidencePresenting;
   float patientsRatioUninfInf;
   int returnCycle;
   int noMachines;
   int maxReagentPerCycle;
   int timeStepsInCycle;
   int batchWaitTime;*/


   vector<Facility*> facilities = list->getListPtr();

   for (auto facility : facilities) {

        facName = facility->getName();

        facAttr = facility->getFacilityAttributesPtr();

        std::cout << "facility = " << facName << "\n";
        
        for (auto a : facAttr) {
            if (a->testing == 1) {
                if (debugFlag) {
                    std::cout << "facattr disease = " << a->disease << ", test = " << a->testName << ", testing = " << a->testing;
                    std::cout << ", facattr incidence = " << a->incidence << ", facattr incAdjType = " << a->incAdjType << ", facattr incAdjFactor = " << a->incAdjFactor;
                    std::cout << ", prpIncPresent = " << a->prpIncidencePresenting << ", patRatioUninfInf = " << a->patientsRatioUninfInf;
                    std::cout << ", perPatientPresentInf = " << a->perPatientPresentInf << ", returnCycle = " << a->returnCycle;
                    std::cout << ", testing = " << a->testing << ", no machines = " << a->noMachines << ", no maxReagentPerCycle = " << a->maxReagentPerCycle;
                    std::cout << ", no timeStepsInCycle = " << a->timeStepsInCycle;
                    std::cout << ", closest facility = " << a->closetConnectionWithTesting << ", closest distance = " << a->closestConnectionDistance << "\n";
                }
            }
        }
   }
}

void dumpFacilityAttributes1(FacilitiesList* list, string where) {

   ofstream myfile;

   string fileOutputName;
   string facName;
   vector<facilityAttributes*> facAttr;

   vector<Facility*> facilities = list->getListPtr();

   fileOutputName = "./stats/dump-facilities/facilities-dump-" + where + ".csv";
   
   myfile.open(fileOutputName);

    myfile << "facility" << ", facattr disease" << ", test" << ", testing" << ", closest facility" << ", closest distance" << "\n";


   for (auto facility : facilities) {

       facName = facility->getName();

       facAttr = facility->getFacilityAttributesPtr();
       for (auto a : facAttr) {
           myfile << facName << "," << a->disease << "," << a->testName << "," << a->testing;
           myfile << "," << a->closetConnectionWithTesting << "," << a->closestConnectionDistance << "\n";
       }
   }

    myfile.close();
}

void dumpDiagnosisAttributes(FacilitiesList* list) {

    string facName;
    Diagnosis* d;
    vector<diagnosisAttributes*> diagAttr;

    vector<Facility*> facilities = list->getListPtr();

    for (auto facility : facilities) {

        facName = facility->getName();
        
        d = facility->getDiagnosisPtr();

        diagAttr = d->getDiagnosisAttributesPtr();

        for (auto diag : diagAttr) {
            std::cout << "facility = " << facName << ", facattr disease = " << diag->disease << ", test = " << diag->testName << ", testing = " << diag->testing;
            std::cout << ", closest facility = " << diag->closetConnectionWithTesting << ", closest distance = " << diag->closestConnectionDistance << "\n";
        }
    }
}



// add pointers to closest connection, now that all the facilities are made
void addClosestPointer(vector<Facility*> facilities) {

    std::size_t i;
    string facName;
    string upName;
    vector<facilityAttributes*> facAttr;


    // loop through each facility and get the Facility pointer for the up and closest 
    // connections (they should be the same at this point) and store in Facility attributes
    for (auto facility : facilities) {

        // get the up name for this facility
        upName = facility->getUpName();

         // loop through list of Facilites and find one that matches
        for (i = 0; i < facilities.size(); i++) {

            facName = facilities[i]->getName();

            // if facility name matches - store pointer in up and closest pointer variables
            if (upName == facName) {

                //std::cout << "found match " << facName << "," << upName << "\n";

                // update the up connection pointer
                facility->setUpPtr(facilities[i]);

                // now loop through all the facility attributes - 
                // if test is done here, it is closest and distance is 0
                // otherwise "up" is closesst and calculate distance
                facAttr = facility->getFacilityAttributesPtr();

                for (auto facSpec : facAttr) {

                    // check to see if testing is done here - if so closest is here
                    if (facSpec->testing > 0) {

                        //facility->setClosestPtr(facility);
                        facSpec->closetConnectionWithTesting = facility->getName();
                        facSpec->closestConnectionDistance = 0;
                    }
                    else {

                        // update closest pointer with up pointer
                        //facility->setClosestPtr(facilities[i]);
                        facSpec->closetConnectionWithTesting = upName;

                        facSpec->closestConnectionDistance = sqrt(pow((facility->getLongitude() - facilities[i]->getLongitude()), 2) + pow((facility->getLatitude() - facilities[i]->getLatitude()), 2));
                    }
                }
            }
        }
    }

}

// add pointers to closest connection, now that all the facilities are made
void addClosestPointer(FacilitiesList* list) {

    std::size_t i;
    string facName;
    string upName;
    vector<facilityAttributes*> facAttr;

    vector<Facility*> facilities = list->getListPtr();

    // loop through each facility and get the Facility pointer for the up and closest 
    // connections .  If testing done here, closest is here otherwise should be up
    for (auto facility : facilities) {
        // get the up name for this facility
        upName = facility->getUpName();

       // std::cout << "add closest pointer facility name =  " << facility->getName() << ", up name = " << upName << "\n";

        // loop through list of Facilites and find one that matches - this will get pointer to up facility
        for (i = 0; i < facilities.size(); i++) {

            facName = facilities[i]->getName();

            // if facility name matches - store pointer in up and closest pointer variables
            if (upName == facName) {

                //std::cout << "found match " << facName << "," << upName << "\n";

                // update the up connection pointer
                facility->setUpPtr(facilities[i]);

                // now loop through all the facility attributes - 
                // if test is done here, it is closest and distance is 0
                // otherwise "up" is closesst and calculate distance
                facAttr = facility->getFacilityAttributesPtr();

                for (auto facSpec : facAttr) {

                    //std::cout << "checking closest and up - facility = " << facility->getName() << ", up = " << upName << ", testing= " << facSpec->testing << "\n";

                    // check to see if testing is done here - if so closest is here
                    if (facSpec->testing > 0) {

                        //facility->setClosestPtr(facility);
                        facSpec->closetConnectionWithTesting = facility->getName();
                        facSpec->closestConnectionDistance = 0;
                    }
                    else {

                        // update closest pointer with up pointer
                        //facility->setClosestPtr(facilities[i]);
                        facSpec->closetConnectionWithTesting = upName;

                        facSpec->closestConnectionDistance = sqrt(pow((facility->getLongitude() - facilities[i]->getLongitude()), 2) + pow((facility->getLatitude() - facilities[i]->getLatitude()), 2));
                    }
                }
            }
        }


    }

}

// Fill in lateral connections on this tier
void fillLatteralConnections(vector<Facility*> facilities) {

    std::size_t i;
    string upName;
    string testUpName;

    // loop through each facility and get the Facility pointer for the up and closest 
    // connections (they should be the same at this point) and store in Facility attributes
    for (auto facility : facilities) {
        // get the up name for this facility
        upName = facility->getUpName();

        // loop through list of Facilites and find one that matches
        for (i = 0; i < facilities.size(); i++) {

            testUpName = facilities[i]->getUpName();

            // if facility up connection name matches - store pointer in latteral connections pointer variables
            if (upName == testUpName) {

                facility->addLatConnection(facilities[i]->getName());
                facility->addLatConnectionPtr(facilities[i]);
            }
        }

    }

}


// Fill in lateral connections on this tier
void fillLatteralConnections(FacilitiesList* list) {

    std::size_t i;
    string upName;
    string testUpName;

    vector<Facility*> facilities = list->getListPtr();

    // loop through each facility and get the Facility pointer for the up and closest 
    // connections (they should be the same at this point) and store in Facility attributes
    for (auto facility : facilities) {
        // get the up name for this facility
        upName = facility->getUpName();

        // loop through list of Facilites and find one that matches
        for (i = 0; i < facilities.size(); i++) {

            testUpName = facilities[i]->getUpName();

            // if facility up connection name matches - store pointer in latteral connections pointer variables
            if (upName == testUpName) {

                facility->addLatConnection(facilities[i]->getName());
                facility->addLatConnectionPtr(facilities[i]);
            }
        }

    }

}
// if testing exists on this tier, loop through and find the closest lateral connection 
// compare it to the up connection and update closest connection if closer
// this is all done by test
void findClosestLateral(vector<Facility*> facilities) {

    float dist;
    float testDist;
    float lon;
    float lat;
    vector<Facility*> latFacilities;
    vector<facilityAttributes*> facAttr;
    vector<facilityAttributes*> facAttrLat;

    for (auto facility : facilities) {

        // now loop through all the facility attributes - 
        // Check this testing against the same disease/test combination for the other facilities
        // If Testing is done here - this is closest latteral, if not, check other facilities on same tier
        // tos see if one is closer than the "Up" connection
        facAttr = facility->getFacilityAttributesPtr();

        for (auto facSpec : facAttr) {

            // only check for facilities that don't have testing
            if (facSpec->testing == 0) {

                // currently set up for up connection as closest
                dist = facSpec->closestConnectionDistance;
                latFacilities = facility->getLatPtr();
                lon = facility->getLongitude();
                lat = facility->getLatitude();

                // std::cout << "distance size " << latFacilities.size() << "\n";

                // loop through list of latteral connections and see if one is closer
                for (auto latFac : latFacilities) {

                    facAttrLat = latFac->getFacilityAttributesPtr();

                    for (auto facSpecLat : facAttrLat) {

                        if (facSpec->disease == facSpecLat->disease) {

                            if (facSpec->testName == facSpecLat->testName) {

                                // only check for facilities that have testing for the same test
                                if (facSpecLat->testing > 0) {

                                    // check distance between lateral connection vs current closest connection
                                    testDist = sqrt(pow(lon - latFac->getLongitude(), 2) + pow(lat - latFac->getLatitude(), 2));

                                    // std::cout << "distance shorter " << testDist << "," << dist << "\n";
                                    // if facility lat connection closer then up or last lat connection replace it
                                    if (testDist < dist) {

                                        //std::cout << "distance shorter for fac = " << latFac->getName() << ", testDist = " << testDist << ", dist = " << dist << "\n";

                                        facSpecLat->closetConnectionWithTesting = latFac->getName();
                                        //facility->setClosestPtr(latFac);
                                        facSpecLat->closestConnectionDistance = testDist;
                                        dist = testDist;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        //std::cout << "find closest lateral - closest name" << facility->getClosestName() << "\n";
    }
}

// if testing exists on this tier, loop through and find the closest lateral connection 
// compare it to the up connection and update closest connection if closer
// this is all done by test
void findClosestLateral(FacilitiesList* list) {

    float dist;
    float testDist;
    float lon;
    float lat;
    vector<Facility*> latFacilities;
    vector<facilityAttributes*> facAttr;
    vector<facilityAttributes*> facAttrLat;

    vector<Facility*> facilities = list->getListPtr();

    for (auto facility : facilities) {

        // now loop through all the facility attributes - 
        // Check this testing against the same disease/test combination for the other facilities
        // If Testing is done here - this is closest latteral, if not, check other facilities on same tier
        // tos see if one is closer than the "Up" connection
        facAttr = facility->getFacilityAttributesPtr();

        for (auto facSpec : facAttr) {

            // only check for facilities that don't have testing
            if (facSpec->testing == 0) {

                // currently set up for up connection as closest
                dist = facSpec->closestConnectionDistance;
                latFacilities = facility->getLatPtr();
                lon = facility->getLongitude();
                lat = facility->getLatitude();

                // std::cout << "distance size " << latFacilities.size() << "\n";

                // loop through list of latteral connections and see if one is closer
                for (auto latFac : latFacilities) {

                    facAttrLat = latFac->getFacilityAttributesPtr();

                    for (auto facSpecLat : facAttrLat) {

                        if (facSpec->disease == facSpecLat->disease) {

                            if (facSpec->testName == facSpecLat->testName) {

                                // only check for facilities that have testing for the same test
                                if (facSpecLat->testing > 0) {

                                    // check distance between lateral connection vs current closest connection
                                    testDist = sqrt(pow(lon - latFac->getLongitude(), 2) + pow(lat - latFac->getLatitude(), 2));

                                    // std::cout << "distance shorter " << testDist << "," << dist << "\n";
                                    // if facility lat connection closer then up or last lat connection replace it
                                    if (testDist < dist) {

                                        //std::cout << "distance shorter for fac = " << latFac->getName() << ", testDist = " << testDist << ", dist = " << dist << "\n";

                                        facSpecLat->closetConnectionWithTesting = latFac->getName();
                                        //facility->setClosestPtr(latFac);
                                        facSpecLat->closestConnectionDistance = testDist;
                                        dist = testDist;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // std::cout << "find closest lateral - closest name  " << facility->getClosestName() << "\n";
    }
}

// check to see if facilites on another tier are closer and can be used
void checkTier(int tierNo, vector<Facility*> facilities) {

    int testing;
    float dist;
    float testDist;
    float lon;
    float lat;
    vector<Facility*> latFacilities;
    vector<facilityAttributes*> facAttr;
    vector<facilityAttributes*> facAttrLat;

    for (auto facility : facilities) {

        // run through all facilities and see if testing is closer for facilites on tierNo

        // now loop through all the facility attributes - 
        // Check this testing against the same disease/test combination for the other facilities
        // If Testing is done here - this is closest latteral, if not, check other facilities on same tier
        // tos see if one is closer than the "Up" connection
        facAttr = facility->getFacilityAttributesPtr();

        for (auto facSpec : facAttr) {

            testing = facSpec->testing;

             //std::cout << "check tier - tiers match for facility = " << facility->getName() << ", tier = " << testing <<  "\n";

            // skip if testing is done here
            if (testing < 1) {

                dist = facSpec->closestConnectionDistance;
                latFacilities = facility->getLatPtr();
                lon = facility->getLongitude();
                lat = facility->getLatitude();

                // std::cout << "distance size " << latFacilities.size() << "\n";

                // loop through list of facilities on tireNo and see if one is closer
                for (auto tierFac : facilities) {

                    // only check Facilities on a given tier
                    if (tierFac->getTier() == tierNo) {

                        // check for similar test for disease
                        facAttrLat = tierFac->getFacilityAttributesPtr();

                        for (auto facSpecLat : facAttrLat) {

                            //std::cout << "check tier - tiers match for facility = " << facility->getName() << ", tier = " << tierNo << ", fac = " << tierFac->getName() << ", disease = " << facSpecLat->disease << ",test = " << facSpecLat->testName << "\n";

                            if (facSpecLat->disease == facSpec->disease){

                                if (facSpecLat->testName == facSpec->testName) {

                                    // check distance between lateral connection vs current closest connection
                                    testDist = sqrt(pow(lon - tierFac->getLongitude(), 2) + pow(lat - tierFac->getLatitude(), 2));

                                    std::cout << "check tier distance shorter for facility = " << facility->getName() << ", tier = " << tierNo << ", fac = " << tierFac->getName() << ", " << testDist << "," << dist << "\n";

                                    // if Facility on another tier is closer, switch
                                    // ignore if testDist = 0, checking against itself
                                    if ((testDist < dist) && (testDist > .0000001)) {

                                        // std::cout << "distance shorter " << testDist << "," << dist << "\n";
                                        facSpecLat->closetConnectionWithTesting = tierFac->getName();
                                        //facility->setClosestPtr(tierFac);
                                        facSpecLat->closestConnectionDistance = testDist;
                                        dist = testDist;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}



// check to see if facilites on another tier are closer and can be used
void checkTier(int tierNo, FacilitiesList* list) {

    float dist;
    float testDist;
    float lon;
    float lat;
    bool testing;
    bool debug = false;
    vector<Facility*> latFacilities;
    vector<facilityAttributes*> facAttr;
    vector<facilityAttributes*> facAttrLat;

    vector<Facility*> facilities = list->getListPtr();

    for (auto facility : facilities) {

        // run through all facilities and see if testing is closer for facilites on tierNo

        // now loop through all the facility attributes - 
        // Check this testing against the same disease/test combination for the other facilities
        // If Testing is done here - this is closest latteral, if not, check other facilities on same tier
        // tos see if one is closer than the "Up" connection
        facAttr = facility->getFacilityAttributesPtr();

        for (auto facSpec : facAttr) {

            dist = facSpec->closestConnectionDistance;
            latFacilities = facility->getLatPtr();
            lon = facility->getLongitude();
            lat = facility->getLatitude();

            testing = facSpec->testing;
            if (debug) std::cout << "check tier facility = " << facility->getName() << ", testing = " << testing << ", closest dist = " << dist << ", tier = " << tierNo << "\n";

            // std::cout << "distance size " << latFacilities.size() << "\n";

            // if testing is done here for this test, nothing can be closer
            if (testing < 1) {
            
                // loop through list of latteral connections and see if one is closer
                for (auto tierFac : facilities) {
                
                    // only check Facilities on a given tier
                    if (tierFac->getTier() == tierNo) {

                        if (debug) std::cout << "check tier - tiers match for facility = " << facility->getName() << ", fac tier = " << tierFac->getTier() << ", tierno = " << tierNo << "\n";
                    
                        // check for similar test for disease
                        facAttrLat = tierFac->getFacilityAttributesPtr();

                        for (auto facSpecLat : facAttrLat) {

                            if (facSpecLat->disease == facSpec->disease) {

                                if (facSpecLat->testName == facSpec->testName) {
                                
                                    // check distance between lateral connection vs current closest connection
                                    testDist = sqrt(pow(lon - tierFac->getLongitude(), 2) + pow(lat - tierFac->getLatitude(), 2));

                                    if (debug) std::cout << "distance shorter " << testDist << "," << dist << "\n";

                                    // if Facility on another tier is closer, switch
                                    // ignore if testDist = 0, checking against itself
                                    if ((testDist < dist) && (testDist > .0000001)) {

                                        facSpec->closetConnectionWithTesting = tierFac->getName();
                                        //facility->setClosestPtr(tierFac);
                                        facSpec->closestConnectionDistance = testDist;
                                        dist = testDist;

                                        if (debug) std::cout << "distance shorter " << testDist << "," << dist << ", facility = " << facility->getName() <<  "\n";
                                        if (debug) std::cout << "closest " << facSpec->closetConnectionWithTesting << ", dist = " << facSpec->closestConnectionDistance <<  "\n";
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}



// Update Diagnosis agent in each Facility to match closest Testing Facility for each test and disease
void updateDiagnosisTesting(FacilitiesList* list) {

    string facName;
    bool debugFlag = false;
    Diagnosis* d;
    vector<diagnosisAttributes*> diagAttr;
    vector<facilityAttributes*> facAttr;

    vector<Facility*> facilities = list->getListPtr();

    //std::cout << "inside updateDiagnosisTesting " << "\n";

    for (auto facility : facilities) {

        facName = facility->getName();
        
        d = facility->getDiagnosisPtr();

        //diagAttr = d->getDiagnosisAttributesPtr();

        facAttr = facility->getFacilityAttributesPtr();

        for (auto facSpec : facAttr) {
            
            // create a diagnosis attribute structure to store specific test and disease information
            diagnosisAttributes* diagnosisAttr = new diagnosisAttributes;

            diagnosisAttr->disease = facSpec->disease;
            diagnosisAttr->testName = facSpec->testName;
            diagnosisAttr->testing = facSpec->testing;
            diagnosisAttr->closetConnectionWithTesting = facSpec->closetConnectionWithTesting;
            diagnosisAttr->closestConnectionDistance = facSpec->closestConnectionDistance;

            d->addDiagnosisAttributeToPtr(diagnosisAttr);
            //diagAttr.push_back(diagnosisAttr);

            if (debugFlag) {
                std::cout << "diagnosis attributes facility = " << facName << ", disease = " << diagnosisAttr->disease << ", testName = " << diagnosisAttr->testName << ", testing = " << diagnosisAttr->testing;
                std::cout << ", closest facility with testing = " << diagnosisAttr->closetConnectionWithTesting << ", " << diagnosisAttr->closestConnectionDistance << "\n";
            }
        }
    }

}




// make sure closest facility distance is correct
void updateClosestDistance(FacilitiesList* list) {

    string closestName;
    float longitude;
    float latitude;
    float cLongitude;
    float cLatitude;
    float distance;
    Facility* pClosest;
    vector<facilityAttributes*> facAttr;

    vector<Facility*> facilities = list->getListPtr();

    // loop through each facility and get the Facility pointer for the closest 
    // calculate distance
    for (auto facility : facilities) {

        distance = 0;

        facAttr = facility->getFacilityAttributesPtr();

        for (auto facSpec : facAttr) {

            // if testing done here - distance is 0
            if (facSpec->testing > 0) {

                distance = 0;
            }
            else {

                // get longitude and latitude for this facility
                longitude = facility->getLongitude();
                latitude = facility->getLatitude();

                // get longitude and latitude for closest facility
                closestName = facSpec->closetConnectionWithTesting;

                pClosest = facilitiesList->getPtr(closestName);
                cLongitude = pClosest->getLongitude();
                cLatitude = pClosest->getLatitude();

                distance = sqrt(pow((longitude - cLongitude), 2) + pow((latitude - cLatitude), 2));
            }

            facSpec->closestConnectionDistance = distance;
        }
    }

}


// create facilities from input file and store in FacilitiesList
void createFacilitesFromInput(FacilitiesList* list, vector<vector<string>> facInput, vector<vector<string>> popData, vector<vector<string>> regionDistrictInput, vector<vector<string>> facSpecific, vector<string> diseaseList, vector<Disease*> dis, vector<Test*> tests, string regionDistrictArray[], int runNo) {


    // loop through vector and create a facility from each line
    // 0 element - up connection, 1 - facility name, 2 - distance to up connection
    // 3 element - type of facility(tier), 4 - longitude, 5 - latitude
    // 6 = region, 7 = district, 8 = facility ID, 9 - Xpert
    // all stored as strings
    // if any population probability data exists, add it to the facility definition
    int baseIndex;
    int attrIndex;
    int tier;
    int pop;
    int totalPop = 0;
    int attrTest = -1;
    int batchWaitTime;
    int regIndex = 0;
    int distIndex = 0;
    float binInc;
    float popBins[10];
    float popDensityBins[10];
    float areaReduction = .5;
    float area;
    float latitude;
    float longitude;
    float distance;
    float totBin;
    float incidence;
    float transmission;
    string incAdjType;
    float incAdjFactor;
    float prpIncidencePresenting;
    float patientsRatioUninfInf;
    float perPatientPresentInf;
    float PI = 3.14159265358979323846;
    bool popDataFlag = false;
    bool foundObject;
    bool xpertHere;
    bool debug1 = false;
    bool debug2 = false;
    bool districtNotFound = true;
    string districtMinusMunicipal;
    string districtMinusMetro1;
    string districtMinusMetro2;
    string districtPlusMunicipal;
    string districtPlusMetro1;
    string districtPlusMetro2;
    string region;
    string district;
    string unitID;
    string str;
    string testName;

    // assume diagnosis at each facility unless changed
    bool diag = true;

    //// create a structure for testing available flags for each disease
    //struct testingAvailableAttr {
    //    string disease;
    //    string testName;
    //    bool testing;
    //};



   vector<testingAvailableAttr *> testing;

   // create a variable to find out if testAvailable is overridden at the regional or district level for each disease
   //testingAvailableAttr testingAvailableOverride[diseaseList.size()];

    // check to see if there is population data to add
    if (popData.size() > 0)
        popDataFlag = true;

    if (debug1)
        std::cout << "CreateFacilities no. of facilities = " << facInput.size() << ", size of popData " << popData.size() << ", facility list size = " << list->getSize() << "\n";


    // skip the first row, it contains column headers
    // 0 = region hospital
    // 1 = facility name
    // 2 = distance to regional hospital
    // 3 = tier (type - hospital, teaching hospital, etc.)
    // 4 = longitude
    // 5 = latitude
    // 6 = region
    // 7 = district
    // 8 = unitID
    // 9 = Xpert

   for (auto i = 1u; i < facInput.size(); i++) {

        if (debug1) {
            std::cout << facInput[i][0] << ',' << facInput[i][1] << ',' << facInput[i][2] << ',' << facInput[i][3] << ',' << facInput[i][4] << ',' << facInput[i][5] << ',' << facInput[i][6] << ',' << facInput[i][7] << ',' << facInput[i][8] << '\n';
        }

        /*for (auto j = 0u; j < diseaseList.size(); j++) {

            testingAvailableOverride[j].disease = diseaseList[j];
            testingAvailableOverride[j].testName = "";
            testingAvailableOverride[j].testing = false;
        }*/

        // find tier for each Facility based off of type
        //tier = findTier(facInput[i][3]);
        tier = stoi(facInput[i][3]);

        //std::cout << "tier no. =  " << tier << ", facInput = " << facInput[i][3]  << "\n";

        // convert distance, longitude and latitude to floats from strings
        distance = stof(facInput[i][2]);
        longitude = stof(facInput[i][4]);
        latitude = stof(facInput[i][5]);

        // get region and district for facility
        region = facInput[i][6];
        district = facInput[i][7];
        if (facInput[i][8] == "yes") {
            xpertHere = true;
        }
        else {
            xpertHere = false;
        }
        unitID = facInput[i][9];

        // convert region and district name to all uppercase
        /*for (size_t i = 0; i < region.size(); i++)
  	    {
  		    region[i] = toupper(region[i]);
  	    }
        for (size_t i = 0; i < district.size(); i++)
  	    {
  		    district[i] = toupper(district[i]);
  	    }*/
        transform(region.begin(), region.end(), region.begin(), ::toupper);
        transform(district.begin(), district.end(), district.begin(), ::toupper);

        // check to see if the district corresponds to one in the district/region list in Main.cpp - otherwise output error message
        district = findDistrictName(district, regionDistrictArray);

        // look for district and region in district/region array for assigning statistics
        // get correct name from district/region array
        distIndex = 0;
        regIndex = 0;

        for (int rdIndex = 0; rdIndex < noElementsDistrictRegionArray; rdIndex++) {

            if (district == regionDistrictArray[rdIndex]) {

                distIndex = rdIndex;
                district = regionDistrictArray[rdIndex];
            }

            if (region == regionDistrictArray[rdIndex]) {

                regIndex = rdIndex;
                region = regionDistrictArray[rdIndex];
            }
        }
        if (distIndex < 1) std::cout << "couldn't find district in district/region array = " << district << "\n";
        if (regIndex < 1) std::cout << "couldn't find region in district/region array = " << region << "\n";

        // debug2 - true
        if (debug2) std::cout << "fac = " << facInput[i][1] << ", distIndex = " << distIndex << ", regIndex = " << regIndex << ", region = " << region << ", last reg = " << regionDistrictArray[16] << "\n";

        //std::cout << "name = " << facInput[i][1] << ",distance = " << distance << ",tier = " << tier << ",longitude = " << longitude << ", latitude = " << latitude << ",region = " << region << ",district = " << district<< ",unit id = " << unitID <<   ", xpert =" << xpertHere <<  '\n';

        // add defaults for population and population density bins
        pop = 5000;
        binInc = .1;
        for (int k = 0; k < 10; k++) {

            popBins[k] = .1 * i + .1;
            popDensityBins[k] = pop * .1 / binInc;
        }

        // zero out bin accumulator - each bin will store the combined proability of all the bins before it
        // so bin[1] is the probablility of bin[0] + probability of bin[1],  This will make calculating 
        // Patients distance easier and faster later.  Just calculate a probablity for patient and if it is less 
        // then the value in the bin, that is the distance from the facility
        totBin = 0;

        //std::cout << "before popdata "  << "\n";

        if (popDataFlag) {
            for (auto j = 1u; j < popData.size(); j++) {
                // remove quotes from pop data 
                str = popData[j][1];
                str.erase(std::remove(str.begin(), str.end(), '\"'), str.end());

                if (str == facInput[i][1]) {
                    //std::cout << "popData 1, 2, 3 " << popData[j][1] << "," << popData[j][2] << ", " << popData[j][3] << "\n";

                    // when creating popDensityBins we take the population in that bin divided by the bin increment
                    // it might be better to increase the bin increment as the index increases to reflect that fact that
                    // each bin is a larger concentric circle than the bin below it 
                    // the area for any bin is approximately area(bin n) - area(bin n-1)
                    // or PI*(binInc*n)^2 - PI*(binInc*(n-1))^2 assuming complete circular bins (no overlap from other facility catchments)
                    // we can use the above formula for area with an adjusting fudge factor to take in the abutting catchments
                    areaReduction = .5;

                    str = popData[j][2];
                    str.erase(std::remove(str.begin(), str.end(), '\"'), str.end());
                    pop = stoi(str);
                    if (pop > 0) {
                        str = popData[j][3];
                        str.erase(std::remove(str.begin(), str.end(), '\"'), str.end());
                        binInc = stof(str);
                        str = popData[j][4];
                        str.erase(std::remove(str.begin(), str.end(), '\"'), str.end());
                        totBin = stof(str);
                        area = pow(PI * binInc,2);
                        popDensityBins[0] = pop * stof(str) / area;
                        popBins[0] = totBin;
                        str = popData[j][5];
                        str.erase(std::remove(str.begin(), str.end(), '\"'), str.end());
                        totBin = totBin + stof(str);
                        area = (pow(PI * (binInc*2),2) - pow(PI * (binInc),2))  * areaReduction;
                        popDensityBins[1] = pop * stof(str) / area;
                        popBins[1] = totBin;
                        str = popData[j][6];
                        str.erase(std::remove(str.begin(), str.end(), '\"'), str.end());
                        totBin = totBin + stof(str);
                        area = (pow(PI * (binInc * 3),2) - pow(PI * (binInc*2),2)) * areaReduction;
                        popDensityBins[2] = pop * stof(str) / area;
                        popBins[2] = totBin;
                        str = popData[j][7];
                        str.erase(std::remove(str.begin(), str.end(), '\"'), str.end());
                        totBin = totBin + stof(str);
                        area = (pow(PI * (binInc * 4),2) - pow(PI * (binInc * 3),2)) * areaReduction;
                        popDensityBins[3] = pop * stof(str) / area;
                        popBins[3] = totBin;
                        str = popData[j][8];
                        str.erase(std::remove(str.begin(), str.end(), '\"'), str.end());
                        totBin = totBin + stof(str);
                        area = (pow(PI * (binInc * 5),2) - pow(PI * (binInc * 4),2)) * areaReduction;
                        popDensityBins[4] = pop * stof(str) / area;
                        popBins[4] = totBin;
                        str = popData[j][9];
                        str.erase(std::remove(str.begin(), str.end(), '\"'), str.end());
                        totBin = totBin + stof(str);
                        area = (pow(PI * (binInc * 6),2) - pow(PI * (binInc * 5),2)) * areaReduction;
                        popDensityBins[5] = pop * stof(str) / area;
                        popBins[5] = totBin;
                        str = popData[j][10];
                        str.erase(std::remove(str.begin(), str.end(), '\"'), str.end());
                        totBin = totBin + stof(str);
                        area = (pow(PI * (binInc * 7),2) - pow(PI * (binInc * 6),2)) * areaReduction;
                        popDensityBins[6] = pop * stof(str) / area;
                        popBins[6] = totBin;
                        str = popData[j][11];
                        str.erase(std::remove(str.begin(), str.end(), '\"'), str.end());
                        totBin = totBin + stof(str);
                        area = (pow(PI * (binInc * 8),2) - pow(PI * (binInc * 7),2)) * areaReduction;
                        popDensityBins[7] = pop * stof(str) / area;
                        popBins[7] = totBin;
                        str = popData[j][12];
                        str.erase(std::remove(str.begin(), str.end(), '\"'), str.end());
                        totBin = totBin + stof(str);
                        area = (pow(PI * (binInc * 9),2) - pow(PI * (binInc * 8),2)) * areaReduction;
                        popDensityBins[8] = pop * stof(str) / area;
                        popBins[8] = totBin;
                        // last bin should always sum to 1 -- last bin density = pop * (1 - cumulative bin values to this point) * binInc
                        area = (pow(PI * (binInc * 10),2) - pow(PI * (binInc * 9),2)) * areaReduction;
                        popDensityBins[0] = pop * (1-totBin) / area;
                        popBins[9] = 1.0;
                    }
                    else {
                        // no population, set up defaults for bins and bin increment distance
                        binInc = .1;
                        for (int k = 0; k < 10; k++) {

                            popBins[k] = .1 * i + .1;
                            popDensityBins[k] = pop * .1 / binInc;
                        }
                    }

                    if (DEBUG5)
                        std::cout << "match " << popData[j][1] << "\n";
                }
            }
        }
        //std::cout << "after popdata " << "\n";
        
        // get testing and diagnosis availability flags for this tier
        // testing may get overridden at the regional, district or facility level
        // testing is controled by tier level - if testing allowed at that tier 
        // get testing flag for each disease

        testing = createTestingAvailableByTier(tier);
        diag = findDiagnosisAvailable(tier);

        // debug2 true false
        if (debug2) {
            for (auto t : testing) {
                std::cout << "testing tier = " << tier << ", disease = " << t->disease << ", test = " << t->testName <<  ", testing = " << t->testing << "\n";
            }
        }

        // debug2 - true
        if (debug2) {
            std::cout << "tier = " << tier;
            for (auto t: testing) {
                std::cout << ", testing disease = " << t->disease << ", test name = " << t->testName << ", testing avail = " << t->testing;
            }
            std::cout << "\n";
            std::cout << "name = " << facInput[i][1] << ", diag = " << diag  << ", pop = " << pop  << "\n";
        }

        if (debug2) {

            if (pop < 1) std::cout << "population less than 1 =  " << pop << " facility = " << facInput[i][1] << "\n";
        }

        // keep track of total population
        totalPop = totalPop + pop;

        if (debug2) std::cout << "before facspecific code " << facSpecific.size() << "\n";

        // need to have the ability to over ride some disease or test parameters.  In general we will use the default disease and default parameters
        // that reside in Tests.csv and diseases.csv.  If we want to over ride the default values for an entire region or district we would
        // put those values into region-district-specific-data.csv.  If we want to override those for a specific facility we put those in 
        // facility-specific-data.csv

        // In order to handle this we store each test for each disease parameters away with the facility in a vector array of
        // facilityAttributes.  
        // 1. Initially we load up the values from facility-specific-data.csv for a specific facility, disease and test
        // We store that away in the vector pointer if we found one.  
        // 2. Next we load up the default parameters from Test.csv and Diseases.csv.
        // 3. If we find any region or district over rides from region-district-specific-data.csv, we overwrite the defaults with those values.
        // 4. Now we check the vector array to see if we already have a facilty specific vector from 1.  If so, we keep it and don't do anything else.
        // if not, we build a facilityAttribute structure and store that away in the vector.  This should give us in order of importance -
        // facility specific, district specific, region specific, default


        // facSpecific vector stores the time between presentation and when the patient needs to return to facility for sample results (returnCycle)
        // It also stores test specific parameters for each facility (ie. no. machines per test, no. of reagents per reagent cycle
        // no. of timesteps in each reagent cycle per test).  Different tests may have different no. of machines and different reagent cycles
        // default no. of machines in each facility with testing at 1 - change this if facility file has different number.  Store whether a Test
        // is done for this disease at this facility with facility attributes
        
        // create a vector of facilityAttribute pointers to be stored at each facility
        vector<facilityAttributes*> attrPtr;

        // loop through facility specific vector and match up facility and tests to current facility - first row has labels
        for (auto j = 1u; j < facSpecific.size(); j++) {

            // check facility names to see if match
            if (facInput[i][1] == facSpecific[j][1]) {

                if (debug2) std::cout << "facSpecific inside name match = "  << facSpecific[j][1] << "\n";

                // now create a facilityAttribute objects based off of string input
                // string input is of the form: row num , Facility Name(1), no. of diseases(2), disease(3), batchWaitTime(4), returnCycle(5), no. of tests(6), test1 name(7), testing(8), Priotity(9), no. of machines1(10)
                //          , max reagents per cycle1(11), timestep in reagent cycle1(12), test2 name(13), testing(14), priority(15), no. of machines2(16) ,max reagents per cycle2(17), timestep in reagent cycle2(18)
                // the columns from no. of tests on can be repeated for multiple tests
                for (int dIndex = 0; dIndex < stoi(facSpecific[j][2]); dIndex++) {

                    // change the 16 if you add more attributes to the disease block, change the 2 if you add anything before the diseases blocks
                    baseIndex = 2 + dIndex * 16;

                    if (debug2) std::cout << "facSpecific tindex limit = "  << facSpecific[j][baseIndex + 3] << "\n";

                    //  stoi(facSpecific[j][baseIndex + 4]) is column of no. of tests to be read
                    for (int tIndex = 0; tIndex < stoi(facSpecific[j][baseIndex + 4]); tIndex++) {

                        // change the 6 if you add more attributes to the tests
                        attrIndex = tIndex * 6;

                        // debug2  true
                        if (debug2) {
                            std::cout << "disease =  " << facSpecific[j][baseIndex + 1];
                            std::cout << " batch wait time =  " << facSpecific[j][baseIndex + 2];
                            std::cout << " Retun time =  " << facSpecific[j][baseIndex + 3];
                            std::cout << " no. of tests =  " << facSpecific[j][baseIndex + 4];
                            std::cout << " test name =  " << facSpecific[j][baseIndex + attrIndex + 5];
                            std::cout << " Testing =  " << facSpecific[j][baseIndex + attrIndex + 6];
                            std::cout << " Priority =  " << facSpecific[j][baseIndex + attrIndex + 7];
                            std::cout << " no. of mach =  " << facSpecific[j][baseIndex + attrIndex + 8];
                            std::cout << " max reag =  " << facSpecific[j][baseIndex + attrIndex + 9];
                            std::cout << " reg ts =  " << facSpecific[j][baseIndex + attrIndex + 10];
                            std::cout << "\n";
                        }

                        facilityAttributes* facAttr = new facilityAttributes;

                        facAttr->disease = facSpecific[j][baseIndex + 1];
                        facAttr->incidence = 0;
                        facAttr->incAdjType = "linear";
                        facAttr->incAdjFactor = 0;
                        facAttr->prpIncidencePresenting = 1;
                        facAttr->patientsRatioUninfInf = 1;
                        facAttr->perPatientPresentInf = 1;
                        facAttr->batchWaitTime = stoi(facSpecific[j][baseIndex+2]);
                        facAttr->returnCycle = stoi(facSpecific[j][baseIndex + 3]);
                        facAttr->testName = facSpecific[j][baseIndex + attrIndex + 5];
                        if (stoi(facSpecific[j][baseIndex + attrIndex + 6]) == 1) {
                            facAttr->testing = true;
                        }
                        else {
                            facAttr->testing = false;
                        }
                        facAttr->priority = stoi(facSpecific[j][baseIndex + attrIndex + 7]);
                        facAttr->noMachines = stoi(facSpecific[j][baseIndex + attrIndex + 8]);
                        facAttr->maxReagentPerCycle = stoi(facSpecific[j][baseIndex + attrIndex + 9]);
                        facAttr->timeStepsInCycle = stoi(facSpecific[j][baseIndex + attrIndex + 10]);

                        attrPtr.push_back(facAttr);

                        // debug2 - true - false
                        if (debug2) {
                            std::cout << "facSpecific made facAttr disease =  " << facAttr->disease << ", incidence = " << facAttr->incidence << ", transmission = " << facAttr->transmission;
                            std::cout << ", incAdjType = " << facAttr->incAdjType << ", incAdjFactor = " << facAttr->incAdjFactor;
                            std::cout << ", prpIncidencePresenting = " << facAttr->prpIncidencePresenting << ", patientsRatioUninfInf = " << facAttr->patientsRatioUninfInf;
                            std::cout << ", perPatientPresentInf = " << facAttr->perPatientPresentInf << ", batchwaittime = " << facAttr->batchWaitTime;
                            std::cout << ", returnCycle = " << facAttr->returnCycle << ", testName = " << facAttr->testName << ", testing = " << facAttr->testing;
                            std::cout << ", priority = " << facAttr->priority << ", no machines = " << facAttr->noMachines << ", no maxReagentPerCycle = " << facAttr->maxReagentPerCycle;
                            std::cout << ", no timeStepsInCycle = " << facAttr->timeStepsInCycle <<  "\n";
                        }
                    }
                }

                break;
            }
        }
        
        if (debug2) std::cout << "facSpecific after loop diseaseList size =  " << diseaseList.size() <<  "\n";

        // now go through the disease list and see if a facilityAttributes object exist for each test case, if not use default values from Test object
        for (auto d : diseaseList) {

            // get default incidence for disease
            incidence = 0;
            incAdjType = "linear";
            incAdjFactor = 0;
            prpIncidencePresenting = 1;
            patientsRatioUninfInf = 1;
            perPatientPresentInf = 1;
            transmission = 0;

            for (auto dStand : dis) {
                if (debug2) std::cout << "facSpecific disease d =  " << d << ", get disease name = " << dStand->getName() << "\n";

                // if matches - pull out incidence and update structure
                if (d == dStand->getName()) {

                    // found the disease - extract the incidence
                    incidence = dStand->getIncidence(0) * 100000 * 365;

                    incAdjType = dStand->getIncAdjType();
                    incAdjFactor = dStand->getIncAdjFactor();
                    prpIncidencePresenting = dStand->getPrpIncPresenting();
                    patientsRatioUninfInf = dStand->getPatientsRatioUninfInf();
                    perPatientPresentInf = dStand->getPerPatientPresentInf();

                    transmission = dStand->getTransmission();

                    // debug2 - true
                    if (debug2) std::cout << "facSpecific disease name match =  " << d << ", incidence =  " << incidence << ", incAdjFactor =  " << incAdjFactor << ", perPatientPresentInf =  " << perPatientPresentInf << "\n";

                    break;
                }
            }
            //debug2 - true
            if (debug2) std::cout << "After disease = " << d << " incidence = " << incidence << " incAdjFactor = " << incAdjFactor << " ratio = " << patientsRatioUninfInf << " perPatientPresentInf = " << perPatientPresentInf << "\n";

            // check to see if region  preferences override default
            for (auto rdIndex = 1u; rdIndex < regionDistrictInput.size(); rdIndex++) {

                if (region == regionDistrictInput[rdIndex][1]) {

                    // match disease as well
                    if (d == regionDistrictInput[rdIndex][2]) {

                        //debug2 - true
                        if (debug2) std::cout << "region disease match region = " << region << " disease = " << d << " action value = " << regionDistrictInput[rdIndex][3] << "\n";

                        // possible values, -1 - use default, 0 - no testing in this region, 1 - testing in this region for this disease
                        if (stoi(regionDistrictInput[rdIndex][3]) == 0) {

                            // reset incidence to zero
                            incidence = 0;
                            incAdjType = "linear";
                            incAdjFactor = 0;
                            prpIncidencePresenting = 1;
                            patientsRatioUninfInf = 1;
                            //perPatientPresentInf = 1;
                        }
                        else if (stoi(regionDistrictInput[rdIndex][3]) == 1) {

                            //debug2 - true
                            if (debug2) std::cout << "reading new region incidence = " << region << " disease = " << d << " action value = " << regionDistrictInput[rdIndex][3] << "\n";

                            // if incidence is 0, keep default disease incidence
                            if (stof(regionDistrictInput[rdIndex][4]) > 0) {

                                incidence = stof(regionDistrictInput[rdIndex][4]);
                                incAdjType = regionDistrictInput[rdIndex][5];
                                incAdjFactor = stof(regionDistrictInput[rdIndex][6]);
                                prpIncidencePresenting = stof(regionDistrictInput[rdIndex][7]);
                                patientsRatioUninfInf = stof(regionDistrictInput[rdIndex][8]);
                                //perPatientPresentInf = stof(regionDistrictInput[rdIndex][9]);
                            }

                            // debug2 - true
                            if (debug2) std::cout << "Changed Incidence or testing for " << d << " for facilities in region " << region << " to incidence = " << incidence << " to incAdjFactor = " << incAdjFactor << "\n";
                        }
                    }
                }
            }
            //debug2 - true
            if (debug2) std::cout << "After regions incidence = " << incidence << " incAdjFactor = " << incAdjFactor <<  "\n";

            districtNotFound = true;

            // check to see if district preferences override default
            for (auto rdIndex = 1u; rdIndex < regionDistrictInput.size(); rdIndex++) {

                if (district == regionDistrictInput[rdIndex][1]) {

                    // match disease as well
                    if (d == regionDistrictInput[rdIndex][2]) {

                        districtNotFound = false;

                        // possible values, -1 - use default, 0 - no testing in this region, 1 - testing in this district for this disease
                        if (stoi(regionDistrictInput[rdIndex][3]) == 0) {

                            // reset incidence to zero
                            incidence = 0;
                            incAdjType = "linear";
                            incAdjFactor = 0;
                            prpIncidencePresenting = 1;
                            //patientsRatioUninfInf = 1;
                        }
                        else if (stoi(regionDistrictInput[rdIndex][3]) == 1) {

                            // if incidence is 0, keep default disease incidence
                            if (stof(regionDistrictInput[rdIndex][4]) > 0) {

                                incidence = stof(regionDistrictInput[rdIndex][4]);
                                incAdjType = regionDistrictInput[rdIndex][5];
                                incAdjFactor = stof(regionDistrictInput[rdIndex][6]);
                                prpIncidencePresenting = stof(regionDistrictInput[rdIndex][7]);
                                patientsRatioUninfInf = stof(regionDistrictInput[rdIndex][8]);
                                //perPatientPresentInf = stof(regionDistrictInput[rdIndex][9]);
                            }

                            // debug2 - true
                            if (debug2) std::cout << "Changed Incidence or testing for " << d << " for facilities in district " << district << " to incidence = " << incidence << " to incAdjFactor = " << incAdjFactor << "\n";
                        }
                    }
                }
            }
            // debug2 - true 
            if (debug2) {

                std::cout << "After district,regions disease = " << d << " incidence = " << incidence << " incAdjFactor = " << incAdjFactor << " prpIncidencePresenting = " << prpIncidencePresenting << "  patientsRatioUninfInf = " << patientsRatioUninfInf << "  perPatientPresentInf = " << perPatientPresentInf << "\n";

                if (districtNotFound) std::cout << "district not found = " << district << "\n";
            }

            foundObject = false;

            // batch wait time to send out samples is either part of facility specific attributes or comes from the tests file
            batchWaitTime = 1;

            // now loop through the tests and make sure a facilityAttributes object exists for the disease-test combination, otherwise create it
            for (auto t : tests) {

                // check to see if there is value in the facility file for incidence or no. of machines for this disease
                if (d == t->getDiseaseName()) {

                    // get time to hold samples for batch sending to other testing facilities and store with facility attributes
                    batchWaitTime = t->getBatchWaitTime();

                    testName = t->getTestName();

                    // debug2 - true - false
                    if (debug2) std::cout << "facSpecific test disease name match =  " << d << " t->getTestName = " << testName << " t->getbatchWaitTime = " << batchWaitTime << ", attrptr size = " << attrPtr.size() << "\n";

                    // now loop through all facilityAttributes and see if ther are any that match disease name and test name
                    // if so ignore, otherwise create a new one and store it away with default values
                    attrTest = -1;

                    for (auto a : attrPtr) {

                        if (debug2) std::cout << "facAttr loop disease =  " << a->disease << ", test name = " << a->testName <<  " , testing = " << a->testing << "\n";

                        if (d == a->disease) {

                            if (testName == a->testName) {

                                foundObject = true;

                                // add latest Incidence
                                a->incidence = incidence;
                                a->transmission = transmission;
                                a->incAdjType = incAdjType;
                                a->incAdjFactor = incAdjFactor;
                                a->prpIncidencePresenting = prpIncidencePresenting;
                                a->patientsRatioUninfInf = patientsRatioUninfInf;
                                a->perPatientPresentInf = perPatientPresentInf;
                                a->batchWaitTime = batchWaitTime;

                                // set test available flag in tests array to match test available flag in facility specific data for this disease and test
                                //t->setDiseaseTesting(a->testing);

                                if (debug2) std::cout << "facSpecific found facilityAttributes already made  arrTest ="  << attrTest << "\n";
                            }
                        }
                    }
                    if (debug2) std::cout << "foundObject =  " << foundObject << " , attrTest = " << attrTest << "\n";

                    if (!foundObject) {

                        foundObject = true;

                        // create a new facilityAttributes object with default values
                        facilityAttributes* facAttr = new facilityAttributes;

                        facAttr->disease = d;
                        facAttr->incidence = incidence;
                        facAttr->transmission = transmission;
                        facAttr->incAdjType = incAdjType;
                        facAttr->incAdjFactor = incAdjFactor;
                        facAttr->prpIncidencePresenting = prpIncidencePresenting;
                        facAttr->patientsRatioUninfInf = patientsRatioUninfInf;
                        facAttr->perPatientPresentInf = perPatientPresentInf;
                        facAttr->batchWaitTime = batchWaitTime;
                        facAttr->returnCycle = returnCycle;
                        facAttr->testName = testName;
                        // dummy state for test available flag
                        /*for (auto taoIndex = 0u; taoIndex < diseaseList.size(); taoIndex++) {

                            if (testingAvailableOverride[taoIndex].disease == d) {

                                facAttr->testing = testingAvailableOverride[taoIndex].testing;
                            }
                        }*/
                        facAttr->testing = false;
                        facAttr->priority = t->getPriority();
                        facAttr->noMachines = t->getNoMachines();
                        facAttr->maxReagentPerCycle = t->getMaxTestPerCycle();
                        facAttr->timeStepsInCycle = t->getReagentCycle();;

                        attrPtr.push_back(facAttr);

                        // debug2 
                        if (debug2) {
                            std::cout << "facSpecific didn't find facilityAttributes made 1  " << "\n";
                            std::cout << "facattr disease = " << facAttr->disease << ", facattr incidence = " << facAttr->incidence << ", facattr incAdjFactor = " << facAttr->incAdjFactor << ", facattr no machines = " << facAttr->noMachines << "\n";
                        }
                    }
                }
            }
            if (debug2) std::cout << "facSpecific after test loop foundObject =  " << foundObject << ", disease = " << d << "\n";

            if (!foundObject) {

                // no test for this disease
                // create one with default values
                std::cout << "***** no test for disease " << d << ", making a dummy unknown one with 1 machine, 28 tests per cycle, 28 time steps in cycle. ************** " << "\n";

                // create a new facilityAttributes object with default values
                facilityAttributes* facAttr = new facilityAttributes;

                facAttr->disease = d;
                facAttr->incidence = incidence;
                facAttr->transmission = transmission;
                facAttr->incAdjType = incAdjType;
                facAttr->incAdjFactor = incAdjFactor;
                facAttr->prpIncidencePresenting = prpIncidencePresenting;
                facAttr->patientsRatioUninfInf = patientsRatioUninfInf;
                facAttr->perPatientPresentInf = perPatientPresentInf;
                facAttr->batchWaitTime = batchWaitTime;
                facAttr->returnCycle = returnCycle;
                facAttr->testName = "unknown";
                // setup testing available flag with no default
                /*for (auto taoIndex = 0u; taoIndex < diseaseList.size(); taoIndex++) {

                    if (testingAvailableOverride[taoIndex].disease == d) {

                        facAttr->testing = testingAvailableOverride[taoIndex].testing;
                    }
                }*/
                facAttr->testing = false;
                facAttr->priority = 1;
                facAttr->noMachines = 1;
                facAttr->maxReagentPerCycle = 28;
                facAttr->timeStepsInCycle = 28;

                attrPtr.push_back(facAttr);
            }
            if (debug2) std::cout << "facSpecific bottom of disease list loop  " << "\n";
        }
        
        // debug2 - true
        if (debug2) {
            for (auto a : attrPtr) {

                //if (a->testName == "Xpert") {

                std::cout << "facattr facility = " << facInput[i][1] << ", disease = " << a->disease << ", test = " << a->testName << ", facattr incidence = " << a->incidence;
                std::cout << ", facattr transmission = " << a->transmission << ", returnCycle = " << a->returnCycle << ", testing = " << a->testing << ", perPatPresentInf = " << a->perPatientPresentInf;
                std::cout << ", no machines = " << a->noMachines << ", no maxReagentPerCycle = " << a->maxReagentPerCycle << ", no timeStepsInCycle = " << a->timeStepsInCycle << "\n";
                //std::cout << "facattr facility = " << facInput[i][1] << ", disease = " << a->disease << ", test = " << a->testName << ", testing = " << a->testing <<  "\n";
                //}
            }
        }

        // update whether testing is done here for this disease.  facAttr->testing will hold the state of testing available for a disease
        // at a facility.  
        // 1.) Testing structure has state of testing available from global tier parameters
        // 2.) facAttr->testing has state of testing available from facility specific attributes
        // 3.) testAvailable has state of testing available from district or regional specific input
        // This is order of implementation - facility attribute then district then regional then tier
        // Update facAttr->testing 
        // facilityAttributes exist, see if there is a testing override
        for (auto a : attrPtr) {

            //std::cout << "before fac = " << facInput[i][1] << ", disease = " << a->disease << ", test = " << a->testName << ", test = " << a->testing <<  "\n";
            
            for (auto t : testing) {

                if (a->disease == t->disease) {

                    
                    // check test match as well
                    if (a->testName == t->testName) {
                        
                        // if test available attribute off, check to see if override from region/district then global Tier
                        if (!a->testing) {
                        
                            if (t->testing) {

                                a->testing = t->testing;

                                //std::cout << "facattr testing overide disease = " << a->disease << ", test = " << a->testName << ", returnCycle = " << a->returnCycle << ", testing = " << a->testing << "\n";
                            }
                        }
                    }
                }
            }

            //std::cout << "after fac = " << facInput[i][1] << ", disease = " << a->disease << ", test = " << a->testName << ", test = " << a->testing <<  "\n";
        }

        // debug2 - true
        if (debug2) {

            for (auto a : attrPtr) {

                //if (a->testName == "Xpert") {
                //if ((a->disease == "HIV") && (a->patientsRatioUninfInf > 1)) {

                std::cout << "facattr facility = " << facInput[i][1] << ", disease = " << a->disease << ", test = " << a->testName << ", returnCycle = " << a->returnCycle;
                std::cout << ", testing = " << a->testing << ", priority = " << a->priority << ", transmission = " << a->transmission << ", no machines = " << a->noMachines << ", no maxReagentPerCycle = " << a->maxReagentPerCycle;
                std::cout << ", no timeStepsInCycle = " << a->timeStepsInCycle << ", batch wait time = " << a->batchWaitTime << ", facattr incidence = " << a->incidence << ", facattr incAdjFactor = " << a->incAdjFactor << ", a->prpIncidencePresenting = " << a->prpIncidencePresenting << ", patientsRatioUninfInf = " << a->patientsRatioUninfInf << "\n";
                //std::cout << "facattr facility = " << facInput[i][1] << ", disease = " << a->disease << ", test = " << a->testName << ", testing = " << a->testing <<  "\n";
                //std::cout << "facattr facility = " << facInput[i][1] << ", disease = " << a->disease << ", test = " << a->testName << ", facattr incidence = " << a->incidence << ", facattr incidence1 = " << a->incidence1 << "\n";
                //std
            }
        }
        
        // debug2 - true
        if (debug2) std::cout << "After facAttr incidence = " << incidence << ", incAdjFactor = " << incAdjFactor <<  "\n";

        // create new facility from data - assume closest is the facility above for now unless testing is done here
        // then assume closest is this new facility and distance is zero
        // pass in desease list and tests list to create correct tests for each facility.
        list->addFacility(new Facility(facInput[i][1], unitID, longitude, latitude, facInput[i][3], facInput[i][0], distance, tier, pop, binInc, popBins, popDensityBins, region, regIndex, district, distIndex, diag, diseaseList, tests, attrPtr, xpertHere));

        // debug2 - true
        if (debug2)  std::cout << "create facility from input after addFacility = " << facInput[i][1] << " population = " << pop <<  "\n";
    }
    if (debug1)   std::cout << "finished making fac " << list->getSize() << "\n";

    // update global parameter with total population
    totalPopulation = totalPop;

    // add pointers to closest connection, now that all the facilities are made, assume it is up for now
    addClosestPointer(list);

    if (debug1) {
    
        std::cout << "-------------------------------------------------------------------------------------------------------------------------" << "\n";
        std::cout << "after addClosestPointer" <<  "\n";
    }

   // debug1 - true
    if (debug1) dumpFacilityAttributes(list);

    // fill in Facilites on the same level under the same parent Facility
    fillLatteralConnections(list);

    if (debug1) {
    
        std::cout << "-------------------------------------------------------------------------------------------------------------------------" << "\n";
        std::cout << "after fillLatteralConnections" << "\n";
    }

    // debug1 - true
    if (debug1)  dumpFacilityAttributes(list);

    // find closest lateral connection that has the testing that you need 
    // if it is closer than parent (up)- it may not exist
    findClosestLateral(list);

    if (debug1) {
    
        std::cout << "-------------------------------------------------------------------------------------------------------------------------" << "\n";
        std::cout << "after findClosestLateral" << "\n";
    }

    if (debug1)  dumpFacilityAttributes(list);

    // now add closest zonal hospital as closest hospital with testing if it is closer than current closest connection
    checkTier(2, list);
    //dumpFacilityAttributes1(list, "tier2");
    //std::cout << "after check tier 2" << "\n";

    // now add national hospital as closest hospital with testing if it is closer than current closest connection
    checkTier(1, list);
    //dumpFacilityAttributes1(list, "tier1");
    //std::cout << "after check tier 1" << "\n";

    // update Diagnosis agents with the new updated closest testing Facility in each Facility
    updateDiagnosisTesting(list);

    //std::cout << "-------------------------------------------------------------------------------------------------------------------------" << "\n";
    //std::cout << "after updateDiagnosisTesting" << "\n";
    //dumpDiagnosisAttributes(list);

    // update closest facility distance
    updateClosestDistance(list);

    //std::cout << "-------------------------------------------------------------------------------------------------------------------------" << "\n";
    //std::cout << "after updateClosestDistance" << "\n";
    //dumpFacilityAttributes1(list, "updateClosestDistance");
    //dumpDiagnosisAttributes(list);
    //dumpFacilityAttributes(list);

    std::cout << "no. of fac " << list->getSize() << "\n";

}


// update up, down and latteral connections for FacilitiesList
void updateFacilityConnections(FacilitiesList* facilities) {

    //std::cout << "inside update Facility connections = " << facilities->getSize() << "\n";
    
    // add pointers to closest connection, now that all the facilities are made, assume it is up for now
    addClosestPointer(facilities);

    //std::cout << "inside update Facility connections after closest pointer" <<  "\n";
    
    // fill in Facilites on the same level under the same parent Facility
    fillLatteralConnections(facilities);

    //std::cout << "inside update Facility connections after latteral" <<  "\n";
    
    // find closest lateral connection that has the testing that you need 
    // if it is closer than parent (up)- it may not exist
    findClosestLateral(facilities);

    //std::cout << "inside update Facility connections after closest latteral" <<  "\n";
    
    // now add closest zonal hospital as closest hospital with testing if it is closer than current closest connection
    checkTier(2, facilities);

    //std::cout << "inside update Facility connections after check tier" <<  "\n";
    
    // now add national hospital as closest hospital with testing if it is closer than current closest connection
    checkTier(1, facilities);


    // update Diagnosis agents with the new updated closest testing Facility in each Facility
    updateDiagnosisTesting(facilities);

    // update closest facility distance
    updateClosestDistance(facilities);

    //std::cout << "leaving update Facility connections" <<  "\n";
}




// create Disease objects from input file
vector<Disease*> createDiseaseObjects(vector<vector<string>> d, vector<vector<string>> runSpecific) {
//vector<Disease*> createDiseaseObjects(vector<vector<string>> d, vector<vector<string>> TBUntreatMort) {

    // loop through vector and create a disease object from each line
    // 0 element - name of disease, 1 - mortality rate, 2 - incidence rate, 
    // 3 - incidence adjustment type, 4 - incidence adjustment factor
    // 5 - transmission, 6 - priority (higher number - higher priority)
    // all stored as strings
    //int i;
    // file format
    // Disease Name	Mortality	Incidence year	  incidence Adjustment type   Incidence adjustment factor   proportion incidence presenting   patient ratio uninf inf   percent patients presenting that are infected
    //Transmission	Priority 	Morbidity	Pre-test MDCD	Pre-test LtoF	Pre-test LtoF for tiers(10) Pre-test death per   space  space  Percentage of patients that return for results	Percentage of samples that are lost in transit
    // No. of patients that receive treatmet after Diagnosis %	Initial treat time (timesteps)	Initial treat success %	Initial treat death %	Pre-treat LtoF %   Pre-treat LtoF % by tiers(10)     treatment LtoF	  treatment LtoF by Tiers(10)
    //Treat failure time (timesteps)	Relapse success %	prob non-infected treated	percent drug resistant	avg. time onset to presentation	percent untreated die
    // percent ltof that die before representing   avg. untested or LtoF representation time
    // max.time.death.retreated  max.time.ltof.represent  max.time.untreat.cure  space	      space	Benefit Tx	Loss to followup P	Loss to followup SP
  
    // this is now replaced with single value
    // // then loop through TB Untreated Mortality file and fill in that array with the correct values for untreated cumulative death mortality by month
    // format: Month (0-12), year(decimal 0-10), cumulative survivability, mortality, cumulative mortality
    // first line is header, second line if values at month 0, third line is values at month 1, etc.
    
    std::size_t i;
    int index = 1;
    int runSpecificSize;
    //std::size_t j;
    float mortality;
    float incidence;
    string incAdjType;
    string namePlusTier;
    string tier;
    string name;
    float incAdjFactor;
    float prpIncidencePresenting;
    float patientsRatioUninfInf;
    float perPatientPresentInf;
    float transmission;
    int priority;
    float morbidity;
    float preTestMDCDInfPer;
    float preTestMDCDUnInfPer;
    float preTestLtoFPer;
    float preTestLtoFPerTier[10];
    float preTestLtoFDeathPer;
    float space1;
    float space2;
    float probReturn;
    float perLostSamples;
    float treatedPer;
    int treatmentTime;
    float initTreatSuccess;
    float initTreatDeath;
    float initTreatDeathIP;
    float preTreatLtoF;
    float preTreatLtoFTier[10];
    float treatLtoF;
    float treatLtoFTier[10];
    float treatLtoFIP;
    int relapseTime;
    float relapseSuccess;
    float probNonInfTreated;
    float perDrugResistant;
    int onsetToPresentation;
    float perUntreatedDie;
    float perLtoFRepresentDie;
    int timeDeathRetreat;
    int maxTimeLtoFRepresent;
    int timeUntreatCure;
    float space3;
    float space4;
    float probRemaining = 100;
    bool debug = false;


    std::vector<Disease*> diseases;

    if (debug) std::cout << "inside create diseases " << '\n';

    // skip the first row, it contains column headers
    for (i = 1; i < d.size(); i++) {

        // debug - true
        if (debug) {
            std::cout << d[i][0] << ' ' << d[i][1] << ' ' << d[i][2] << ' ';
            std::cout << d[i][33] << ' ' << d[i][34] << ' ' << d[i][35] << '\n';
        }

        // convert mortality and incidence to floats from strings
        index = 1;
        mortality = stof(d[i][index]);
        index = index + 1;
        incidence = stof(d[i][index]);
        index = index + 1;
        incAdjType = d[i][index];
        index = index + 1;
        incAdjFactor = stof(d[i][index]);
        index = index + 1;
        prpIncidencePresenting = stof(d[i][index]);
        index = index + 1;
        patientsRatioUninfInf = stof(d[i][index]);
        index = index + 1;
        perPatientPresentInf = stof(d[i][index]);
        index = index + 1;
        transmission = stof(d[i][index]);
        index = index + 1;
        priority = stoi(d[i][index]);
        index = index + 1;
        morbidity = stof(d[i][index]);
        index = index + 1;
        preTestMDCDInfPer = stof(d[i][index]);
        index = index + 1;
        preTestMDCDUnInfPer = stof(d[i][index]);
        index = index + 1;
        // debug - true
        if (debug) {

            std::cout << "inside create diseases preTestMDCDInfPer = " << d[i][index - 2] << ", preTestLtoFPer = " << d[i][index - 1] << '\n';
            std::cout << "inside create diseases preTestMDCDInfPer = " << preTestMDCDInfPer << ", preTestLtoFPer = " << preTestLtoFPer << '\n';
        }
        preTestLtoFPer = stof(d[i][index]);
        index = index + 1;
        for (int j = 0; j < 10; j++) {
            preTestLtoFPerTier[j] = stof(d[i][index]);
            index = index + 1;
        }
        preTestLtoFDeathPer = stof(d[i][index]);
        index = index + 1;
        space1 = stof(d[i][index]);
        index = index + 1;
        space2 = stof(d[i][index]);
        index = index + 1;
        probReturn = stof(d[i][index]);
        index = index + 1;
        perLostSamples = stof(d[i][index]);
        index = index + 1;
        treatedPer = stof(d[i][index]);
        index = index + 1;
        treatmentTime = stoi(d[i][index]);
        index = index + 1;
        initTreatSuccess = stof(d[i][index]);
        index = index + 1;
        initTreatDeath = stof(d[i][index]);
        index = index + 1;
        // store away original value in case we change it in the program (ex. TB)
        initTreatDeathIP = initTreatDeath;
        preTreatLtoF = stof(d[i][index]);
        index = index + 1;
        // debug - true
        if (debug) {

            std::cout << "inside create diseases preTreatLtoF = " << preTreatLtoF << '\n';
            std::cout << "inside create diseases preTreatLtoFTier[0] = " << stof(d[i][index]) << '\n';
        }
        for (int j = 0; j < 10; j++) {
            preTreatLtoFTier[j] = stof(d[i][index]);
            index = index + 1;
        }
        treatLtoF = stof(d[i][index]);
        index = index + 1;
        // store away original value in case we change it in the program (ex. TB)
        // debug - true
        if (debug) {

            std::cout << "inside create diseases treatLtoF = " << treatLtoF << '\n';
            std::cout << "inside create diseases treatLtoFTier[0] = " << stof(d[i][index]) << '\n';
        }
        treatLtoFIP = treatLtoF;
        for (int j = 0; j < 10; j++) {
            treatLtoFTier[j] = stof(d[i][index]);
            index = index + 1;
        }
        relapseTime = stoi(d[i][index]);
        index = index + 1;
        relapseSuccess = stof(d[i][index]);
        index = index + 1;
        probNonInfTreated = stof(d[i][index]);
        index = index + 1;
        perDrugResistant = stof(d[i][index]);
        index = index + 1;
        onsetToPresentation = stoi(d[i][index]);
        index = index + 1;
        perUntreatedDie = stof(d[i][index]);
        index = index + 1;
        perLtoFRepresentDie = stof(d[i][index]);
        index = index + 1;
        timeDeathRetreat = stoi(d[i][index]);
        index = index + 1;
        maxTimeLtoFRepresent = stoi(d[i][index]);
        index = index + 1;
        timeUntreatCure = stoi(d[i][index]);
        index = index + 1;
        space3 = stof(d[i][index]);
        index = index + 1;
        space4 = stof(d[i][index]);
        // debug - true
        if (debug) std::cout << "inside create diseases after space4 = " << '\n';

        if (d[i][0] == "TB") {

            // need to adjust treatLtoF and initTreatDeath for TB
            // instead of entering the probability for each of these diseases, the values are the percentage of the remaining probability
            // the order of checking is success, ltof, death, relapse
            // if success is 85%, that leaves a probability of 15 percent for the remaining 3 cases
            // if treatLtoF is 33% then it is 33% of the remaining 15 proability or 5% leaving a probability of 10% for the remaining 2 cases
            // if death is 90% then it is 90% of the remaining 10% probability or 9% leavinga probability of 1% for relapse
            // we will recalculate the probabilities into the true remaining probilities here
            
            // debug - true
            if (debug) std::cout << "for TB initTreatSucess =  " << initTreatSuccess << ", treatLtoF =  " << treatLtoF << ", initTreatDeath =  " << initTreatDeath << '\n';
            
            probRemaining = 100 - initTreatSuccess;

            treatLtoF = probRemaining * treatLtoF/100;

            probRemaining = probRemaining - treatLtoF;

            initTreatDeath = probRemaining * initTreatDeath/100;

            probRemaining = probRemaining - initTreatDeath;

            if (debug) std::cout << "for TB initTreatSucess =  " << initTreatSuccess << ", treatLtoF =  " << treatLtoF << ", initTreatDeath =  " << initTreatDeath << '\n';
        }

        if (debug) std::cout << "inside create diseases after read disease " << d[i][0] << ", preTestMDCDInfPer = " << preTestMDCDInfPer << ", preTestMDCDUnInfPer = " << preTestMDCDUnInfPer << ", space3 = " << space3 << ", space4 = " << space4 << '\n';

        // seperate out the diseases from the diseases-tier data
        namePlusTier = d[i][0];
        tier = "-tier";

        if (namePlusTier.find(tier) == namePlusTier.npos) {
            
            // create the disease
            // diseases.push_back(new Disease(d[i][0], mortality, incidence, transmission, priority));
            //diseases.push_back(new Disease(d[i][0], mortality, incidence, incAdjType, incAdjFactor, transmission, priority, morbidity, preTestLtoFPer,  preTestLtoFDeathPer, space1, space2, probReturn, perLostSamples, treatedPer, treatmentTime, initTreatSuccess, initTreatDeath, preTreatLtoF, treatLtoF, relapseTime, relapseSuccess, probNonInfTreated, perDrugResistant, onsetToPresentation, perUntreatedDie, timeDeathRetreat, perLtoFRepresentDie, timeDeathRetreat, maxTimeLtoFRepresent, timeUntreatCure));
            //diseases.push_back(new Disease(d[i][0], mortality, incidence, incAdjType, incAdjFactor, prpIncidencePresenting, patientsRatioUninfInf, transmission, priority, morbidity, preTestLtoFPer, preTestLtoFDeathPer, space1, space2, probReturn, perLostSamples, treatedPer, treatmentTime, initTreatSuccess, initTreatDeath, initTreatDeathIP, preTreatLtoF, treatLtoF, treatLtoFIP, relapseTime, relapseSuccess, probNonInfTreated, perDrugResistant, onsetToPresentation, perUntreatedDie, timeDeathRetreat, perLtoFRepresentDie, timeDeathRetreat, maxTimeLtoFRepresent, timeUntreatCure));
            diseases.push_back(new Disease(d[i][0], mortality, incidence, incAdjType, incAdjFactor, prpIncidencePresenting, patientsRatioUninfInf, perPatientPresentInf, transmission, priority, morbidity, preTestMDCDInfPer, preTestMDCDUnInfPer, preTestLtoFPer, preTestLtoFPerTier, preTestLtoFDeathPer, space1, space2, probReturn, perLostSamples, treatedPer, treatmentTime, initTreatSuccess, initTreatDeath, initTreatDeathIP, preTreatLtoF, preTreatLtoFTier, treatLtoF, treatLtoFTier, treatLtoFIP, relapseTime, relapseSuccess, probNonInfTreated, perDrugResistant, onsetToPresentation, perUntreatedDie, timeDeathRetreat, perLtoFRepresentDie, timeDeathRetreat, maxTimeLtoFRepresent, timeUntreatCure));

            if (debug) std::cout << "inside create diseases after create disease = " << d[i][0] << '\n';
        }
        else {

            // store region and tier based loss to follow up in the correct disease object
            name = namePlusTier.substr(0, namePlusTier.length() - 5);
            //std::cout << "inside create diseases after create disease loss to follow up values " << name << " region " << incAdjType << '\n';

            // find the disease that matches and update loss to followup tier values
            for (auto dis : diseases) {

                if (debug) std::cout << "name - " << name << ", disName - " << dis->getName() << '\n';

                if (name == dis->getName()) {

                    if (debug) std::cout << "inside create diseases after create disease loss to follow up values found match " << name << " region " << incAdjType << " dis->name " << dis->getName() << '\n';
                    
                    for (int i = 0; i < 10; i++) {
                        
                        dis->setPerPreTestLtoFTierRegion(incAdjType, i, preTestLtoFPerTier[i]);
                        dis->setPreTreatmentLtoFTierRegion(incAdjType, i, preTreatLtoFTier[i]);
                        dis->setTreatmentLtoFTierRegion(incAdjType, i, treatLtoFTier[i]);

                    }

                    if (debug) std::cout << "inside create diseases preTestLtoFPerTier[3] " << preTestLtoFPerTier[3] << ", preTestLtoFPerTier[4] " << preTestLtoFPerTier[4] << '\n';

                    break;
                }
            }
        }
    }
    if (DEBUG5) {
        std::cout << d.size();
    }

    // update transmission flag from run specific file
  
    if (debug) std::cout << "inside create diseases before update transmission flags " << '\n';

    runSpecificSize = runSpecific.size();

    // see if we need to turn transmission on for any diseases
    for (int i = 0; i < runSpecificSize; i++) {

        // check column 0 for trans flag row
        if (runSpecific[i][0] == "TransList") {

            // if disease name matches TransList - turn on transmission for that disease
            for (auto dis : diseases) {
                    
                if (runSpecific[i][1] == dis->getName()) {

                    dis->turnTransFlagOn();
                    dis->setTransThreshold(stof(runSpecific[i][2]));
                }
            }
        }
    }

    // debug - true
    if (debug) {

        for (auto dis : diseases) {

            std::cout << "inside create disease = " << dis->getName() << " Transmission flag = " << dis->getTransFlag() << '\n';

            if (dis->getName() == "HIV") {

                dis->dumpPerPreTestLtoFTierRegion();
                dis->dumpPreTreatmentLtoFTierRegion();
                dis->dumpTreatmentLtoFTierRegion();
            }
        }
    }

    //for (auto dis : diseases) {

    //    if (debug) std::cout << "inside create diseases before TB untreated mortality " << '\n';

    //    if (dis->getName() == "TB") {
    //        
    //        // skip the first two rows, it contains column headers and values for month 0
    //        for (j = 1; j < TBUntreatMort.size(); j++) {

    //            if (debug) std::cout << "inside create diseases inside TB untreated mortality j = " << j-1 << " value = " << TBUntreatMort[j][4] << '\n';

    //            dis->setUntreatedMortality(j-1, stof(TBUntreatMort[j][4]));
    //        }
    //    }
    //}
    
    return diseases;
}


// create Disease objects from input file
vector<Test*> createTestObjects(vector<vector<string>> t) {

    // loop through vector and create a test object from each line
    // 0 element - name of test, 1 - disease, 2 - priority, 
    // 3 - Batch Wait Time, 4 - patient Return time, 5 -Max test per machine, 6 - No. times machine can be use per time step, 7 - Max tests per day, 8 - Tests this time step
    // 9 - Max tests in cycle, 10 - Reagent cycle in timesteps, 11 -	Sensitivity, 12 - Specificity, 13 -	MD Sensitivity, 14 - MD Specificity
    // 15 - MDwithTestSn, 16 - MDwithTestSp

    // all stored as strings
    //int i;
    std::size_t i;
    string name;
    string disease;
    int priority;
    int batchWaitTime;
    int patientReturnTime;
    int testsPerMachine;
    int cyclesPerTimestep;
    int maxTestPerDay;
    int maxTestPerCycle;
    int reagentCycle;
    float sensitivity;
    float specificity;
    float sensitivityMD;
    float specificityMD;
    float sensitivityWithTestMD;
    float specificityWithTestMD;
    bool tier0 = false;
    bool tier1 = false;
    bool tier2 = false;
    bool tier3 = false;
    bool tier4 = false;
    bool tier5 = false;
    bool tier6 = false;
    bool tier7 = false;
    bool tier8 = false;
    bool tier9 = false;
    bool debug = false;


    std::vector<Test*> tests;

    if (debug) std::cout << "inside create tests " << '\n';

    // skip the first row, it contains column headers
    for (i = 1; i < t.size(); i++) {

        if (debug) {
            std::cout << t[i][0] << ' ' << t[i][1] << ' ' << t[i][2] << ' ' << t[i][4] << ' ' << t[i][5] << ' ' << t[i][6] << ' ' << t[i][7] << ' ' << t[i][8] << '\n';
        }

        // convert mortality and incidence to floats from strings
        name = t[i][0];
        disease = t[i][1];
        priority = stoi(t[i][2]);
        batchWaitTime = stoi(t[i][3]);
        patientReturnTime = stoi(t[i][4]);
        testsPerMachine = stoi(t[i][5]);
        cyclesPerTimestep = stoi(t[i][6]);
        maxTestPerDay = stoi(t[i][7]);
        // testThisTimeStep = stoi(t[i][8]);
        maxTestPerCycle = stoi(t[i][9]);
        reagentCycle = stoi(t[i][10]);
        sensitivity = stof(t[i][11]);
        specificity = stof(t[i][12]);
        sensitivityMD = stof(t[i][13]);
        specificityMD = stof(t[i][14]);
        sensitivityWithTestMD = stof(t[i][15]);
        specificityWithTestMD = stof(t[i][16]);

        //debug - true
        if (debug) {
            std::cout << name << ' ' << disease << ' ' << testsPerMachine << ' ' << cyclesPerTimestep << ' ' << maxTestPerDay << ' ' << maxTestPerCycle << ' ' << reagentCycle << ' ' << priority << ' ' << sensitivity << ' ' << specificity << ' ' << sensitivityMD << ' ' << specificityMD << '\n';
        }
        
        // grab tiers values for each test out of GlobalParameters
        tier0 = findTestingAvailable(0, disease, name);
        tier1 = findTestingAvailable(1, disease, name);
        tier2 = findTestingAvailable(2, disease, name);
        tier3 = findTestingAvailable(3, disease, name);
        tier4 = findTestingAvailable(4, disease, name);
        tier5 = findTestingAvailable(5, disease, name);
        tier6 = findTestingAvailable(6, disease, name);
        tier7 = findTestingAvailable(7, disease, name);
        tier8 = findTestingAvailable(8, disease, name);
        tier9 = findTestingAvailable(9, disease, name);

        if (debug) {
            std::cout << " after findTestingAvailale" << '\n';
        }

        // diseases.push_back(new Disease(d[i][0], mortality, incidence, transmission, priority));
        tests.push_back(new Test(name, disease, testsPerMachine, cyclesPerTimestep, maxTestPerDay, maxTestPerCycle, reagentCycle, priority, batchWaitTime, patientReturnTime, sensitivity, specificity, sensitivityMD, specificityMD,  sensitivityWithTestMD, specificityWithTestMD, tier0, tier1, tier2, tier3, tier4, tier5, tier6, tier7, tier8, tier9));
        //Test::Test(string name, string disease, int testsPerMachine, int cyclesPerTimestep, int maxTestPerTimestep, int maxTestPerCycle, int reagentCycle, int priority, int batchWaitTime, int patientReturnTime, float sensitivity, float specificity, float sensitivityMD, float specificityMD, float sensitivityWithTestMD, float specificityWithTestMD, bool tier0, bool tier1, bool tier2, bool tier3, bool tier4, bool tier5, bool tier6, bool tier7, bool tier8, bool tier9) {

        if (debug) {
            std::cout << " after test.push_back" << '\n';
        }
    }
    if (debug) {
        std::cout << "leaving createTestObjects size = " << t.size() << '\n';
    }

    return tests;
}

// create population bins from facility longitude and latitude and population cluster points
vector<vector<string>> createPopBins(vector<vector<string>> facInput, vector<vector<string>> populationData, vector<vector<string>> travelTime, int distanceTime) {

  
    // // populationData has the format 
    // 0 = row number
    // 1 = longitude
    // 2 = latitude
    // 3 = population

    // facInput has the format incorrect
    // 0 = region hospital, 
    // 1 = facility name, 
    // 2 = distance to regional hospital
    // 3 = tier (type - hospital, teaching hospital, etc.)
    // 4 = longitude
    // 5 = latitude
    // 6 = region
    // 7 = district
    // 8 = xpert
    // 9 = unitID

    // distance distanceTime determines whether to use distance or time to calculate the population bins
    // distance uses crows flies distance (calculated here) from facility to population clusters
    // to determine which population cluster is store with which facility
    // time uses the time it takes to travel to a facility.  These are calculated in the the InputOutput
    // routine - updateTravelCatch.  The catchments are already calculated and just retrieved here
    // distanceTime = 1 for crows fly distance calculations
    // distanceTime = 2 for travel time calculations

    int noFacilities;
    int noPopClusters;
    int noCatch;
    int n;
    float dist;
    float newDist;
    float checkDist;
    float saveCheckDist;
    string checkName;
    bool fileFlag = true;
    bool foundCheckDist;
    bool debug = false;
    ofstream myfile;
    ofstream myfile1;
    ofstream myfile2;

    vector<string> lines[facInput.size()];

    // two structures to used to calculate population catchment population bins
    struct popClust {
        float longitude;
        float latitude;
        float population;
        string facName;
        float distance;
    };

    struct facData {
        string facName;
        float longitude;
        float latitude;
        float distance;
        int tier;
        int population;
        float binInc;
        float binPop[10];
        float binDist[10];
    };

    struct travelTimeCatch {
        float longitude;
        float latitude;
        float travelTime;
        string facName;
    };

    vector<vector<string>> popData;
    vector<vector<string>> catchData;

    noPopClusters = populationData.size();
    noFacilities = facInput.size();
    noCatch = travelTime.size();

    if(debug) std::cout << "inside createPopBins noFac = " << noFacilities << ", noPopCluster = " << noPopClusters << ", noCatch = " << noCatch << "\n";

    popClust* popPoints = new popClust[noPopClusters];
    facData* facList = new facData[noFacilities];
    travelTimeCatch* catchList = new travelTimeCatch[noCatch];

    //std::cout << "inside createPopBins after variables \n";
    //std::cout << facInput[1][0] << ',' << facInput[1][1] << ',' << facInput[1][2] << ',' << facInput[1][3] << ',' << facInput[1][4] << ',' << facInput[1][5] << '\n';
    //std::cout << populationData[1][0] << ',' << populationData[1][1] << ',' << populationData[1][2] << ',' << populationData[1][3] << '\n';

    // convert from string to float
    for (int i = 1; i < noPopClusters; i++) {
        popPoints[i].longitude = stof(populationData[i][1]);
        popPoints[i].latitude = stof(populationData[i][2]);
        // check for NA in population column
        if (populationData[i][3].find("NA") != string::npos) {
            popPoints[i].population = 0;
        }
        else {
            // input population is from 2015.  Adjust it to current starting year
            popPoints[i].population = stof(populationData[i][3]) * popInitialGrowthRate;

            if (false) std::cout << "inside createPopBins popInitialGrowthRate = " << popInitialGrowthRate << " pop before = " << stof(populationData[i][3]) <<  " pop after = " << popPoints[i].population << "\n";
        }
        popPoints[i].facName = "None";
        popPoints[i].distance = 0;

        if (debug && (i < 5)) std::cout << popPoints[i].longitude << ',' << popPoints[i].latitude << ',' << popPoints[i].population << '\n';
    }

    if(debug) std::cout << "inside createPopBins after popClusters = " << noPopClusters << "\n";

    // convert from string to float
    for (int i = 1; i < noFacilities; i++) {

        if (debug && (i < 5)) std::cout << facInput[i][1] << ',' << facInput[i][4] << ',' << facInput[i][5] << ',' << facInput[i][3] << '\n';

        facList[i].facName = facInput[i][1];
        //facList[i].tier = findTier(facInput[i][3]);
        facList[i].tier = stoi(facInput[i][3]);
        facList[i].longitude = stof(facInput[i][4]);
        facList[i].latitude = stof(facInput[i][5]);
        facList[i].distance = 0;
        facList[i].population = 0;
        facList[i].binInc = 0;
        for (int j = 1; j < 10; j++) {
            facList[i].binPop[j] = 0;
            facList[i].binDist[j] = 0;
        }

        if (debug && (i < 5)) std::cout << facList[i].facName << ',' << facList[i].longitude << ',' << facList[i].latitude << ',' << facList[i].tier << '\n';
    }

    if(debug) std::cout << "inside createPopBins after facilities = " << noFacilities << " noCatch = " << noCatch <<  "\n";

    // remove any leading spaces from facility names
    const char* letters = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

    // read in time for travel catchments if using accessmod 5 stuff
    if (distanceTime == 2) {

        for (int i = 1; i < noCatch; i++) {

            if (debug && (i < 5)) std::cout << travelTime[i][0] << ',' << travelTime[i][1] << ',' << travelTime[i][2] << ',' << travelTime[i][3] << '\n';

            catchList[i].longitude = stof(travelTime[i][0]);
            catchList[i].latitude = stof(travelTime[i][1]);
            catchList[i].travelTime = stoi(travelTime[i][2]);

            // if first letter is something other than a number or letter - remove it
            n = travelTime[i][3].find_first_of(letters);
            if (n == 1) {
                catchList[i].facName = travelTime[i][3].substr(1);
            }
            else {
                catchList[i].facName = travelTime[i][3];
            }

            if (debug && (i < 5)) std::cout << catchList[i].longitude << ',' << catchList[i].latitude << ',' << catchList[i].travelTime << ',' << catchList[i].facName << '\n';
        }
    }

    if(debug) std::cout << "inside createPopBins after catchments " << "\n";


    // dump statistics for each population cluster point - only do it to file
    if (fileFlag) {
        myfile.open("./stats/createPopBins-pop.csv");
        myfile1.open("./stats/createPopBins-fac.csv");
        myfile << "row.no." << ",longitude" << ",latitude " << ",population" << ",facName" << ",distance" << " \n";
        myfile1 << "longitude" << ",latitude" << ",population" << ",facName" << ",distance" << ",tier" << ",binInc" << ",1" << ",2" << ",3" << ",4" << ",5" << ",6" << ",7" << ",8" << ",9" << ",10" << " \n";
    }


    // save population catchment bins away in a file so we don't have to create it again
    myfile2.open("./stats/Facility-Catchment-Population-Distribution.csv");
    myfile2 << "row no." << ",facName" << ",population" << ",binInc" << ",1" << ",2" << ",3" << ",4" << ",5" << ",6" << ",7" << ",8" << ",9" << ",10 " << " \n";
    lines[0].push_back("row.no.");
    lines[0].push_back("facName");
    lines[0].push_back("population");
    lines[0].push_back("binInc");
    lines[0].push_back("1");
    lines[0].push_back("2");
    lines[0].push_back("3");
    lines[0].push_back("4");
    lines[0].push_back("5");
    lines[0].push_back("6");
    lines[0].push_back("7");
    lines[0].push_back("8");
    lines[0].push_back("9");
    lines[0].push_back("10");
    popData.push_back(lines[0]);

    if (distanceTime == 1) {

        // find which facility is closest to each population cluster point - save it's name and distance
    // skip the first row, it contains column headers
        for (int i = 1; i < noPopClusters; i++) {

            dist = 10;

            // make sure population is at least 1
            if (popPoints[i].population >= 1) {

                // loop through facility list
                for (int j = 1; j < noFacilities; j++) {

                    // std::cout << "inside createPopBins inside second loop popPoints pop = " << popPoints[i].population << ", fac = " << facList[j].facName << ", tier  = " << facList[j].tier << " \n";

                    // ignore national lab and zonal labs
                    if (facList[j].tier > 2) {
                        // make sure at least within 1 degree
                        //if ((abs(popPoints[i].longitude - facList[j].longitude) + abs(popPoints[i].latitude - facList[j].latitude)) < 2) {

                        newDist = sqrt(pow((popPoints[i].longitude - facList[j].longitude), 2) + pow((popPoints[i].latitude - facList[j].latitude), 2));

                        if (newDist < dist) {

                            // update distance and facility name for this point
                            popPoints[i].facName = facList[j].facName;
                            popPoints[i].distance = newDist;
                            dist = newDist;
                        }
                        //}
                    }
                }
            }
        }
    }
    else if (distanceTime == 2) {

        if (debug) std::cout << "using travel time pop bins " << " \n";

        // find the closest population cluster point and get the facility name from the catchment 
        for (int i = 1; i < noPopClusters; i++) {

            dist = 10;

            // make sure population is at least 1
            if (popPoints[i].population >= 1) {

                // loop through facility list
                for (int j = 1; j < noCatch; j++) {

                    // std::cout << "inside createPopBins inside second loop popPoints pop = " << popPoints[i].population << ", fac = " << facList[j].facName << ", tier  = " << facList[j].tier << " \n";

                    newDist = sqrt(pow((popPoints[i].longitude - catchList[j].longitude), 2) + pow((popPoints[i].latitude - catchList[j].latitude), 2));

                    if (newDist < dist) {

                        // update distance and facility name for this point
                        popPoints[i].facName = catchList[j].facName;
                        popPoints[i].distance = catchList[j].travelTime;
                        dist = newDist;
                    }

                }
            }
        }
    }
    else {

        // error condition
        std::cout << " Error = using neither distance or time for population bin calculation " << " \n";

    }

    if (debug) std::cout << "after bin calculations " << " \n";

    if (fileFlag) {
        for (int i = 1; i < noPopClusters; i++) {
            myfile << i << "," << popPoints[i].longitude << "," << popPoints[i].latitude << "," << popPoints[i].population << "," << popPoints[i].facName << "," << popPoints[i].distance << "\n";
        }
    }

    // find the greatest distance/time away for any population cluster point associated with facility and save it away
    // Total the populations for each facility
    for (int i = 1; i < noFacilities; i++) {

        // loop through population clusters list
        for (int j = 1; j < noPopClusters; j++) {
            // ignore national lab and zonal labs
            if (popPoints[j].facName == facList[i].facName) {

                // compare against distance away to see if greater
                if (popPoints[j].distance > facList[i].distance) {

                    facList[i].distance = popPoints[j].distance;
                }

                // add to population
                facList[i].population = facList[i].population + popPoints[j].population;

                //std::cout << " found match ****** fac name= " << facList[i].facName << ", pop fac name = " << popPoints[j].facName << ", pop = " << facList[i].population << ", distance = " << facList[i].distance << " \n";
            }
        }
    }

    if (debug) std::cout << "found max distance away " << " \n";

    // now calculate bin increment to determine geographical distance/time for each bin
    for (int i = 1; i < noFacilities; i++) {

        // force a bin increment of .1 if only one population/travel time point for a facility
        // the one it is located on
        if ((facList[i].distance < .00001) && (facList[i].population > 0)) {
            facList[i].binInc = .1;
        }
        else {
            facList[i].binInc = facList[i].distance / 10;
        }
    }

    if (debug) std::cout << "found bin increment " << " \n";

    // store population clusters in the bin that closest matches the distance/time from the facility
    for (int i = 1; i < noFacilities; i++) {

        // loop through population clusters list
        for (int j = 1; j < noPopClusters; j++) {

            // ignore national lab and zonal labs
            if (popPoints[j].facName == facList[i].facName) {

                for (int k = 1; k <= 11; k++) {

                    // take 1 binInc steps away from facility, when farther than cluster distance/time, store it in the previous popBin

                    if (popPoints[j].distance < float(k) * facList[i].binInc) {

                        if (k > 10) {
                            k = 10;
                        }

                        facList[i].binPop[k - 1] = facList[i].binPop[k - 1] + popPoints[j].population;

                        break;
                    }
                }
            }
        }
    }

    if (debug) std::cout << "finished storing pop clusters in bins " << " \n";

    // calculate percentage probability for each bin
    for (int i = 1; i < noFacilities; i++) {

        for (int j = 0; j < 10; j++) {

            // ignore 0 population bins
            if (facList[i].binPop[j] == 0) {
                facList[i].binDist[j] = 0;
            }
            else {
                facList[i].binDist[j] = facList[i].binPop[j] / facList[i].population;
            }
        }
    }

    if (debug) std::cout << "finished calc of probability for bins " << " \n";

    // check to see if there are any facilities with 0 population
    // if so, see if there is another facility with the same coordinates
    // split the population between the two facilities and copy the catchments
    for (int i = 0; i < noFacilities; i++) {

        if (facList[i].population == 0) {

            foundCheckDist = false;
            saveCheckDist = 100;
            checkName = "";
            
            for (int j = 1; j < noFacilities; j++) {

                checkDist = sqrt(pow((facList[i].longitude - facList[j].longitude), 2) + pow((facList[i].latitude - facList[j].latitude), 2));

                if ((j != i) && (checkDist < saveCheckDist)) {

                    saveCheckDist = checkDist;
                    checkName = facList[j].facName;
                }

                if ((j != i) && (checkDist == 0)) {

                    std::cout << " found pop zero name= " << facList[i].facName << " found fac match name= " << facList[j].facName << " \n";
                    // copy halve population
                    facList[j].population = facList[j].population / 2;
                    facList[i].population = facList[j].population; 
                    
                    for (int k = 0; k < 10; k++) {

                        // copy pop bins
                        facList[i].binDist[k] = facList[j].binPop[k];
                        facList[i].binDist[k] = facList[j].binDist[k];
                    }
                    foundCheckDist = true;
                    break;
                }
            }
            if (!foundCheckDist) std::cout << " found zero pop name= " << facList[i].facName << " no zero dist match saveCheckDist = " << saveCheckDist << " at " << checkName << " \n";
        }
    }
    // now remove split zero populations within 1 km
    for (int i = 0; i < noFacilities; i++) {

        if (facList[i].population == 0) {

            foundCheckDist = false;

            for (int j = 1; j < noFacilities; j++) {

                checkDist = sqrt(pow((facList[i].longitude - facList[j].longitude), 2) + pow((facList[i].latitude - facList[j].latitude), 2));

                if ((j != i) && (checkDist < .01)) {

                    std::cout << " found pop zero name= " << facList[i].facName << " found fac match name= " << facList[j].facName << " \n";
                    // copy halve population
                    facList[j].population = facList[j].population / 2;
                    facList[i].population = facList[j].population;

                    for (int k = 0; k < 10; k++) {

                        // copy pop bins
                        facList[i].binDist[k] = facList[j].binPop[k];
                        facList[i].binDist[k] = facList[j].binDist[k];
                    }
                    foundCheckDist = true;
                    break;
                }
            }
            if (!foundCheckDist) std::cout << " found zero pop name= " << facList[i].facName << " \n";
        }
    }
    for (int i = 0; i < noFacilities; i++) {

        if (facList[i].population == 0) {

            std::cout << " still found pop zero name= " << facList[i].facName << " \n";
        }
    }


    // // output the as a csvfile
    if (fileFlag) {
        for (int i = 1; i < noFacilities; i++) {
            myfile1 <<  facList[i].longitude << "," << facList[i].latitude << "," << facList[i].population << "," << facList[i].facName << "," << facList[i].distance << "," << facList[i].tier << "," << facList[i].binInc << "," << facList[i].binDist[0] << "," << facList[i].binDist[1] << "," << facList[i].binDist[2] << "," << facList[i].binDist[3] << "," << facList[i].binDist[4] << "," << facList[i].binDist[5] << "," << facList[i].binDist[6] << "," << facList[i].binDist[7] << "," << facList[i].binDist[8] << "," << facList[i].binDist[9] << "\n";
        }
        myfile.close();
        myfile1.close();
    }

    // save it away to file 
    for (int i = 1; i < noFacilities; i++) {
        myfile2 << i << "," << facList[i].facName << "," << facList[i].population << "," << facList[i].binInc << "," << facList[i].binDist[0] << "," << facList[i].binDist[1] << "," << facList[i].binDist[2] << "," << facList[i].binDist[3] << "," << facList[i].binDist[4] << "," << facList[i].binDist[5] << "," << facList[i].binDist[6] << "," << facList[i].binDist[7] << "," << facList[i].binDist[8] << "," << facList[i].binDist[9] << "\n";
        
        // now convert it back into a string vector
        lines[i].push_back(to_string(i));
        lines[i].push_back(facList[i].facName);
        lines[i].push_back(to_string(facList[i].population));
        lines[i].push_back(to_string(facList[i].binInc));
        lines[i].push_back(to_string(facList[i].binDist[0]));
        lines[i].push_back(to_string(facList[i].binDist[1]));
        lines[i].push_back(to_string(facList[i].binDist[2]));
        lines[i].push_back(to_string(facList[i].binDist[3]));
        lines[i].push_back(to_string(facList[i].binDist[4]));
        lines[i].push_back(to_string(facList[i].binDist[5]));
        lines[i].push_back(to_string(facList[i].binDist[6]));
        lines[i].push_back(to_string(facList[i].binDist[7]));
        lines[i].push_back(to_string(facList[i].binDist[8]));
        lines[i].push_back(to_string(facList[i].binDist[9]));

        popData.push_back(lines[i]);
    }
    myfile2.close();


    
    return popData;
}


// create a patient at a given facility, they will present at the give time step with given disease, patient is assumed to be infected
Patient* createPatient(FacilitiesList* list, string facility, vector<Disease*> dis, string diseaseName, vector<Test*> tests, int timeStep) {

    //float mort;
    //float incid;
    //float trans;
    int n;
    int priority;
    int facilityReturnTime;
    int transitTime;
    int batchWaitTime = 1;
    int distIndex = 0;
    int regIndex = 0;
    int popBinIndex = 0;
    int onsetToPresentTime = 0;
    float distance;
    float perLostSamples = 0;
    float rand;
    float* popBins;
    bool infected = true;       // assume patient is infected
    bool testingAvailable;
    bool debugOn = false;
    bool debugOn1 = false;
    string diseaseOnListName;
    string patientDiseaseName;
    string closestName;
    string testName;
    Patient* p = NULL;
    Sample* s;
    Diagnosis* d;
    Facility* fac;
    Facility* facClosest;
    Facility* testFacility;
    Facility* remoteTestFacility;
    Stats* stat = NULL;
    Stats* facilityStat = NULL;
    vector<facilityAttributes*> fa;

    // debugOn1 - true
    if (debugOn1) {
        std::cout << "inside create patients" << "\n";
    }
    // get Facility pointer from Facility name
    fac = facilitiesList->getPtr(facility);

    // now for each disease in that we are modeling, extract incidence to calculate no. of patients to create
    // loop through the list of diseases to create and get the chacteristics of that disease
    for (auto k = 0u; k < dis.size(); k++) {

        // get disease name from list of diseases to watch
        diseaseOnListName = dis[k]->getName();

        // default values
        //incid = 0;
        priority = 0;

        // if disease found update the disease parameters and create patient
        if (diseaseOnListName == diseaseName) {

            patientDiseaseName = diseaseName;
            //mort = dis[k]->getMortality();
            //trans = dis[k]->getTransmission();
            priority = dis[k]->getPriority();
            perLostSamples = dis[k]->getPerLostSamples();
            stat = dis[k]->getStatsPtr();
            facilityStat = dis[k]->getFacStatsPtr();
            //patientsRatioUninfInf = dis[k]->getPatientsRatioUninfInf();
            onsetToPresentTime = dis[k]->getTimeOnsetToPresentation();

            // debugOn1 - true
            if (debugOn1) {
                std::cout << "inside create patient disease list name = " << diseaseOnListName << ", disease name = " << diseaseName << ", totalPopulation = " << totalPopulation << "\n";
                std::cout << "***********countSeqPopTB = " << countSeqPopTB << ", nextNoSeqPopTB = " << nextNoSeqPopTB << "\n";
            }

            // create infected patient at facility
            // store in popbin number input
                           
            // no longer only check for Xpert test
            testingAvailable = fac->testingAvailableAny(patientDiseaseName);
            testName = fac->testingAvailableName(patientDiseaseName);
            popBins = fac->getPopBins();

            // make patient
            // generate a random number between 0 and 1.  This will tell you which bin (and the corresponding distance/time) for each patient
            rand = (float)getNextRandomNo100() / (fac->getPopulation() * 100);

            // calculate distance from facility
            n = -1;
            do {
                n++;
                // std::cout << "popbins " << n << "," << popBins[n] << "\n";
            } while (rand > popBins[n] && n < 9);

            distance = (float)(n + 1) * fac->getBinInc();

            if (testingAvailable) {

                p = new Patient(fac->getName(), fac->getDistrict(), fac->getDistrictIndex(), fac->getRegion(), fac->getRegionIndex(), patientDiseaseName, distance, popBinIndex, infected, PatInUnTest, testName, timeStep + onsetToPresentTime);

                //std::cout << "patient testing here facility =  " << fac->getName() << ", dist = " << fac->getDistrict();
                //std::cout << ", dist index = " << fac->getDistrictIndex() << ", reg = " << fac->getRegion() <<  ", reg ind = " << fac->getRegionIndex() << "\n";

                // update number of additional infected and uninfected patients
                dis[k]->incAddInfPatients();

                // patient already here - testing here
                facilityReturnTime = 0;

                // mark where sample is being tested
                p->setSampleTestFacility(fac->getName());

                // debugOn - true - false
                if (debugOn) {
                    std::cout << "patient here, testing here facility =  " << fac->getName() << ", return time = " << facilityReturnTime << "\n";
                }
            }
            else {

                // find nearest test facility and find the highest priority test for this disease that it does
                remoteTestFacility = facilitiesList->getPtr(fac->getClosestNameByDisease(patientDiseaseName, fac->getUpName()));
                testName = remoteTestFacility->testingAvailableName(patientDiseaseName);

                if (debugOn) {
                    std::cout << "remote test facility = " << remoteTestFacility << " name = " << fac->getName() << " testName = " << testName;
                    std::cout << " patientDiseaseName = " << patientDiseaseName << " distance = " << distance << " infected = " << infected;
                    std::cout << " distance = " << distance << " PatAwayUnTest = " << PatAwayUnTest << "\n";
                }

                p = new Patient(fac->getName(), fac->getDistrict(), fac->getDistrictIndex(), fac->getRegion(), fac->getRegionIndex(), patientDiseaseName, distance, popBinIndex, infected, PatAwayUnTest, testName, timeStep + onsetToPresentTime);

                // update number of additional infected and uninfected patients
                dis[k]->incAddInfPatients();
                
                // find out when patient should return to the facility for test results for this disease and store with patient
                facilityReturnTime = fac->getTestReturnTime((patientDiseaseName), testName);

                // debugOn - true
                if (debugOn) {
                    std::cout << "patient remote testng facilityReturnTime = " << facilityReturnTime << ", district index = " << fac->getDistrict() << ", " << fac->getDistrictIndex() << "\n";
                }

                // mark where sample is being tested
                p->setSampleTestFacility(remoteTestFacility->getName());

                // debugOn - true - false
                if (debugOn) {
                    std::cout << "patient away, no testing here facility =  " << fac->getName() << ", return time = ";
                    std::cout << facilityReturnTime << ", remote facility = " << remoteTestFacility->getName() << ", test name = " << testName << "\n";
                }
            }
            
            if (debugOn) std::cout << "new patient getIDint =  " << fac->getIDint() << "\n";
            
            // update facility id for patient
            p->setFacilityID(fac->getIDint());
            p->setFacilityTier(fac->getTier());

            int temp = p->getFacilityID();
            if (debugOn) std::cout << "new patient p->setFacilityID =  " << temp << " tier = " << fac->getTier() <<  "\n";

            // find the region and district indices for stats counting
            distIndex = p->getFacilityDistrictIndex();
            regIndex = p->getFacilityRegionIndex();

            // debugOn - true
            if (debugOn) std::cout << "patient region district =  " << regIndex << ", " << distIndex << ", disease = " << p->getDisease() << ", facility = " << fac->getName() << "\n";


            // count patients new and infected
            if (statsCount) {

                stat->record_nPatient(distIndex, regIndex);
                facilityStat->record_nPatient(fac->getIDint());

                if (infected) {

                    stat->record_nPatientInf(distIndex, regIndex);
                    facilityStat->record_nPatientInf(fac->getIDint());
                }

                stat->record_nPatientFromTrans(distIndex, regIndex);
                facilityStat->record_nPatientFromTrans(fac->getIDint());

                // debugOn
                if (debugOn) std::cout << "patient stats stored in distIndex = " << distIndex << " district = " << stat->returnDistrict(distIndex) << " regIndex = " << regIndex << ", region = " << stat->returnRegion(regIndex) << "\n";
            }

            p->setFacilityReturnTime(facilityReturnTime);

            // keep track of patients that re-present
            p->setRepresentFlag(true);
            p->setRepresentTime(timeStep + onsetToPresentTime);

            // set patient away from facility return time
            p->setFacilityReturnTime(onsetToPresentTime);

            // treat transmission patient as reprentation patient that will present at current timestep plus onset to presentation time for disease
            p->setSampleTestStatus("SampUnTestWaitRepresent");

            if (debugOn) std::cout << "after creating patient facility Return time = " << facilityReturnTime << "\n";

            // find out if this strain is or will become drug resistant - disease dependent
            //randInt = distribution(generator);

            //if (randInt < perDrugResistant) {
            //    p->setDrugResistant(true);
            //}
            //else {
            //    p->setDrugResistant(false);
            //}

            // add patient to transmission patient container
            d = fac->getDiagnosisPtr();
            //d->storePatient(p);
            d->storeTransPatient(p);

            // debugOn - true - false
            if (debugOn) {

                std::cout << "after adding patient to list " << "\n";

                //std::cout << "create patient " << fac[foundIndex]->getName() << ", closest facility = " << fac[foundIndex]->getClosestName(patientDiseaseName, fac[foundIndex]->getName()) << ", closest distance = " << fac[foundIndex]->getClosestDistance() << ", infected = " << infected << "\n";
            }

            //std::cout << "create patient " << fac[foundIndex]->getName() << ", closest facility = " << fac[foundIndex]->getClosestNameByDisease(patientDiseaseName, fac[foundIndex]->getName()) << ", closest distance = ";
            //std::cout << fac[foundIndex]->getClosestDistByDisease(patientDiseaseName, fac[foundIndex]->getName()) << ", disease name = " << patientDiseaseName << ", infected = " << infected << "\n";

            // create samples for each of the Patients
            //testingAvailable = fac[foundIndex]->testingAvailable(patientDiseaseName,"Xpert");
            //testingAvailable = fac[foundIndex]->testingAvailableAny(patientDiseaseName);
            //testName = fac[foundIndex]->testingAvailableName(patientDiseaseName);

            if (testingAvailable) {

                // change status to patient waiting to return for in-house testing
                p->setStatus(PatInUnTest);
                
                // testing done here - change closest testing facility to here and distance to 0
                s = new Sample(p, facility, fac->getTier(), facility, 0, patientDiseaseName, infected, priority, perLostSamples);

                // store pointer with patient
                p->setSamplePtr(s);

                s->setStatus(SampUnTestWaitRepresent);

                // count samples done in-house
                if (statsCount) {

                    stat->record_nSamplesIn(distIndex, regIndex);
                    facilityStat->record_nSamplesIn(fac->getIDint());
                    stat->record_sPatientWaitingIn(distIndex, regIndex);
                    facilityStat->record_sPatientWaitingIn(fac->getIDint());
                    stat->record_sSampleWaitingForTestIn(distIndex, regIndex);
                    facilityStat->record_sSampleWaitingForTestIn(fac->getIDint());
                }

                // update Sample status to in-transit - calculate transit time by distance to travel for testing
                transitTime = 0;

                // update the sample to the current test available here
                testName = fac->getTestName(patientDiseaseName);
                s->setTest(testName);

                // find test pointer that matches disease and test
                /*for (auto tp : tests) {

                    if ((tp->getTestName() == testName) && (tp->getDiseaseName() == diseaseName)) {

                        s->setTestPtr(tp);
                    }
                }*/

                // debugOn - true - false
                if (debugOn) std::cout << "inside cp sample here " << facility << " for " << patientDiseaseName << " test fac name = " << fac->getClosestNameByTest(patientDiseaseName, testName) << " distPerTimeStep = " << distancePerTimeStep << " transitTime = " << transitTime << " testing = " << testingAvailable << " test name = " << testName << "\n";
            }
            else {

                // testing done remotely
                
                // debugOn - true - false
                if (debugOn) {

                    fa = fac->getFacilityAttributesPtr();

                    for (auto facSpec : fa) {

                        std::cout << "test = " << facSpec->testName << ", up connection =  " << facSpec->closetConnectionWithTesting;;
                        std::cout << ", up connection =  " << fac->getClosestNameByDisease(patientDiseaseName, fac->getUpName()) << ", dist = " << fac->getClosestDistByDisease(patientDiseaseName, fac->getUpName()) << "\n";
                    }
                }

                // change status to patient out but returning
                p->setStatus(PatAwayUnTest);

                s = new Sample(p, facility, fac->getTier(), fac->getClosestNameByDisease(patientDiseaseName, fac->getUpName()), fac->getClosestDistByDisease(patientDiseaseName, fac->getUpName()), patientDiseaseName, infected, priority, perLostSamples);

                // store pointer with patient
                p->setSamplePtr(s);

                s->setStatus(SampUnTestWaitRepresent);

                // update Sample status to in-transit - calculate transit time by distance to travel for testing
                transitTime = (int)ceil(fac->getClosestDistByDisease(patientDiseaseName, fac->getUpName()) / distancePerTimeStep);

                if (transitTime < 1) {

                    // if testing isn't here make sure it takes at least one time step to transport it
                    transitTime = 1;
                }


                // count samples done at another testing facility
                if (statsCount) {

                    stat->record_nSamplesOut(distIndex, regIndex);
                    facilityStat->record_nSamplesOut(fac->getIDint());
                    stat->record_timeSampleTransport(transitTime, distIndex, regIndex);
                    facilityStat->record_timeSampleTransport(transitTime, fac->getIDint());
                    stat->record_nTransported(distIndex, regIndex);
                    facilityStat->record_nTransported(fac->getIDint());
                    stat->record_sPatientWaitingOut(distIndex, regIndex);
                    facilityStat->record_sPatientWaitingOut(fac->getIDint());
                    stat->record_sSampleWaitingForTestOut(distIndex, regIndex);
                    facilityStat->record_sSampleWaitingForTestOut(fac->getIDint());
                }

                // update the sample to the current test available at the facility the sample is being sent to
                testFacility = facilitiesList->getPtr(fac->getClosestNameByDisease(patientDiseaseName, fac->getUpName()));

                testName = testFacility->getTestName(patientDiseaseName);
                s->setTest(testName);

                // find test pointer that matches disease and test
                for (auto tp : tests) {

                    if ((tp->getTestName() == testName) && (tp->getDiseaseName() == diseaseName)) {

                        s->setTestPtr(tp);
                    }
                }

                // debugOn - true - false
                if (debugOn) std::cout << "inside cp sample away " << facility << " for " << patientDiseaseName << ", name = " << fac->getUpName() << ", distPerTimeStep = " << distancePerTimeStep << " transitTime = " << transitTime << " testing = " << testingAvailable << " test name = " << testName << "\n";
            }

            // update batch wait time for sample based on Disease
            // default to no batch time
            batchWaitTime = fac->getBatchWaitTime(patientDiseaseName);

            // update batch wait time for sample based on Disease
            s->setBatchWaitTime(batchWaitTime);

            // update patient agent with sample pointer
            //p->setSamplePtr(s);

            // update Sample status to in-transit - calculate transit time by distance to travel for testing
            //transitTime = (int)ceil(fac[foundIndex]->getClosestDistByDisease(patientDiseaseName, fac[foundIndex]->getName()) / distancePerTimeStep);

            // debugOn - true - false
            if (debugOn) std::cout << "inside create patient " << timeStep + onsetToPresentTime << " batchWaitTime = " << batchWaitTime << " transitTime = " << transitTime << " testing = " << testingAvailable << "\n";

            // if 0 transit days, testing is available here
            if (transitTime < 1) {
                s->setStatus(SampCreatedUnTest);   // New - no transit already at testing station

                s->setTransitTime(0);
                s->setTransitTimeSave(0);

                // set how long waiting in batch to 0
                s->setBatchWaitTimeSave(0);
            }
            else {

                // testing done at another Facility
                // Check to see if must wait for batch sending - determine this by checking timeStep mod batch interval
                // if no remainder, send sample  - otherwise hold it
                if (debugOn) std::cout << "inside create patient before batch wait timestep " << timeStep + onsetToPresentTime << " batchWaitTime = " << batchWaitTime << "\n";

                if ((batchWaitTime == 0) || ((timeStep + onsetToPresentTime) % batchWaitTime == 0)) {

                    if (debugOn) std::cout << "inside create patient sending out sample " << "\n";

                    // time to send out batch of samples
                    s->setStatus(SampUnTestInTransit); // set status to in transit

                    s->setTransitTime(transitTime);
                    s->setTransitTimeSave(transitTime);

                    // set how long waiting in batch to 0
                    s->setBatchWaitTimeSave(0);
                }
                else {

                    if (debugOn) std::cout << "inside create patient not yet hold sample " << "\n";

                    // not yet, hold sample until next time steps
                    s->setStatus(SampCreatedUnTestBatch); // set status to waiting for batch transit

                    s->setTransitTime(transitTime);
                    s->setTransitTimeSave(transitTime);

                    // set how long waiting in batch to days left before sending out in batch mode
                    s->setBatchWaitTimeSave((timeStep + onsetToPresentTime) % batchWaitTime);
                }
            }

            // note when sample was created
            s->setCreateTime(timeStep + onsetToPresentTime);
            p->setCreateTime(timeStep + onsetToPresentTime);
            if (debugOn) std::cout << "inside create patient sample created =  " << timeStep + onsetToPresentTime << "\n";

            // now add Sample to _testingFacility _sampleContainer
            //f = facilitiesList->getPtr(fac[foundIndex]->getClosestName());
            if (testingAvailable) {
                closestName = facility;
            }
            else {
                closestName = fac->getClosestName(patientDiseaseName);
                //closestName = fac->getClosestNameByTest(patientDiseaseName, "Xpert");
                //closestName = fac->getClosestNameByDisease(patientDiseaseName, fac->getName());
            }

            if (debugOn) {
                std::cout << "facility = " << fac->getName() << ", testing available = " << testingAvailable << ", transit time " << transitTime << ", closest name " << closestName << "\n";
            }

            //std::cout << "in create patients add sample to testing facility = " << closestName << ", orig-facility = " << fac[foundIndex]->getName() << "\n";
            //f = fac[foundIndex]->getClosestPtr();
            facClosest = facilitiesList->getPtr(closestName);
            if (debugOn) {
                std::cout << "after getptr " << "\n";
            }

            if (facClosest) {
                facClosest->addToSampleContainer(s);
                //std::cout << "after add to sample " << "\n";
            }
            else {
                std::cout << "couldn't find testing Facilty for new Sample " << facility << ", " << "\n";
            }

            //std::cout << "***********after m array  countSeqPopTB = " << countSeqPopTB << ", nextNoSeqPopTB = " << nextNoSeqPopTB << "\n";

            //debugOn1 true false
            if (debugOn1)
                std::cout << "created patient for disease " << diseaseName << "\n";
        }
        //debugOn1 true false
        if (debugOn1)
            std::cout << "after disease while loop " << diseaseOnListName << "\n";
    }

    return p;

}

// create a new patient from old patient
void copyPatient(Patient* patient, FacilitiesList* list, int timestep, bool ageFlag, bool genderFlag, Stats* stat, Stats* facilityStat) {


    int age = 0;
    int gender = 0;
    int distIndex;
    int regIndex;
    string disease;
    bool debugOn = false;
    Patient* p;
    Facility* fac;
    Diagnosis* d;
    Sample* s;
    Sample* oldSample;
    vector<facilityAttributes*> fa;


    // get all patient attributes, create patient, store in same facility
    // create sampe and send through system
    
    // if timeStep is zero, create at current global timeStep
    if (timestep == 0) {

        timestep = timeStep;
    }

    // if ageFlag is true, create patient of same age, otherwise randomize age
    if (ageFlag) {

        age = patient->getAge();
    }
    else {

        age = getNextRandomNo100() % 63;
    }

    // if genderFlag is true, create patient of same gender, otherwise randomize
    if (genderFlag) {

        gender = patient->getGender();
    }
    else {

        gender = getNextRandomNo100() % 2;
    }

    distIndex = patient->getFacilityDistrictIndex();
    regIndex = patient->getFacilityRegionIndex();
    disease = patient->getDisease();

    // get facility associated with patient
    fac = list->getPtr(patient->getFacility());

    if (fac->testingAvailableAny(patient->getDisease())) {

        p = new Patient(patient->getFacility(), patient->getFacilityDistrict(), distIndex, patient->getFacilityRegion(), regIndex, disease, patient->getDistance(), patient->getPopBinIndex(), patient->getInfected(), PatInUnTest, patient->getSampleTest(), age, gender, timeStep);
    }
    else {

        p = new Patient(patient->getFacility(), patient->getFacilityDistrict(), distIndex, patient->getFacilityRegion(), regIndex, disease, patient->getDistance(), patient->getPopBinIndex(), patient->getInfected(), PatAwayUnTest, patient->getSampleTest(), age, gender, timeStep);
    }
    
    // mark where sample is being tested
    p->setSampleTestFacility(patient->getSampleTestFacility());

    // count patients
    if (statsCount) {

        stat->record_nPatient(distIndex, regIndex);
        facilityStat->record_nPatient(fac->getIDint());

        if (p->getInfected()) {

            stat->record_nPatientInf(distIndex, regIndex);
            facilityStat->record_nPatientInf(fac->getIDint());
        }

        // debugOn
        if (debugOn) std::cout << "copied patient stats stored in distIndex = " << distIndex << " district = " << stat->returnDistrict(patient->getFacilityDistrictIndex()) << " regIndex = " << regIndex << ", region = " << stat->returnRegion(patient->getFacilityRegionIndex()) << "\n";
    }

    p->setFacilityReturnTime(patient->getFacilityReturnTime());

    // add patient to patient container for facility
    d = fac->getDiagnosisPtr();
    d->storePatient(p);

    oldSample = patient->getSamplePtr();

    if (fac->testingAvailableAny(disease)) {

        // testing done here - change closest testing facility to here and distance to 0
        s = new Sample(p, fac->getName(), fac->getTier(), fac->getName(), 0, disease, patient->getInfected(), oldSample->getPriority(), oldSample->getPerLostSamples());

        // count samples done in-house
        if (statsCount) {

            stat->record_nSamplesIn(distIndex, regIndex);
            facilityStat->record_nSamplesIn(fac->getIDint());
            stat->record_sPatientWaitingIn(distIndex, regIndex);
            facilityStat->record_sPatientWaitingIn(fac->getIDint());
            stat->record_sSampleWaitingForTestIn(distIndex, regIndex);
            facilityStat->record_sSampleWaitingForTestIn(fac->getIDint());
        }

        // debugOn - true - false
        if (debugOn) std::cout << "inside cp sample here " << fac->getName() << " for " << disease << " test fac name = " << fac->getClosestNameByTest(disease, oldSample->getTest()) << " transitTime = " << oldSample->getTransitTime() << " testing = " << fac->testingAvailableAny(disease) << " test name = " << oldSample->getTest() << "\n";
    }
    else {

        // debugOn - true - false
        if (debugOn) {

            fa = fac->getFacilityAttributesPtr();

            for (auto facSpec : fa) {

                std::cout << "test = " << facSpec->testName << ", up connection =  " << facSpec->closetConnectionWithTesting;;
                std::cout << ", up connection =  " << fac->getClosestNameByDisease(disease, fac->getUpName()) << ", dist = " << fac->getClosestDistByDisease(disease, fac->getUpName()) << "\n";
            }
        }


        s = new Sample(p, fac->getName(), fac->getTier(), fac->getClosestNameByDisease(disease, fac->getUpName()), fac->getClosestDistByDisease(disease, fac->getUpName()), disease, patient->getInfected(), oldSample->getPriority(), oldSample->getPerLostSamples());

        // count samples done at another testing facility
        if (statsCount) {

            stat->record_nSamplesOut(distIndex, regIndex);
            facilityStat->record_nSamplesOut(fac->getIDint());
            stat->record_timeSampleTransport(oldSample->getTransitTime(), distIndex, regIndex);
            facilityStat->record_timeSampleTransport(oldSample->getTransitTime(), fac->getIDint());
            stat->record_nTransported(distIndex, regIndex);
            facilityStat->record_nTransported(fac->getIDint());
            stat->record_sPatientWaitingOut(distIndex, regIndex);
            facilityStat->record_sPatientWaitingOut(fac->getIDint());
            stat->record_sSampleWaitingForTestOut(distIndex, regIndex);
            facilityStat->record_sSampleWaitingForTestOut(fac->getIDint());
        }

        // debugOn - true - false
        if (debugOn) std::cout << "inside cp sample away " << fac->getName() << " for " << disease << ", name = " << fac->getUpName() << " transitTime = " << oldSample->getTransitTime() << " testing = " << fac->testingAvailableAny(patient->getDisease()) << " test name = " << oldSample->getTest() << "\n";
    }


    // store pointer with patient
    p->setSamplePtr(s);

    // update new sample with old sample information
    s->setTransitTime(oldSample->getTransitTime());
    
    // set test pointer that matches disease and test
    s->setTest(oldSample->getTest()); 
    s->setTestPtr(oldSample->getTestPtr());
    
    // update batch wait time for sample based on Disease
    s->setBatchWaitTime(oldSample->getBatchWaitTime());

   



}





void createPatients(vector<Facility*> fac, FacilitiesList* list, std::vector<string> diseaseList, vector<Disease*> dis, vector<Test*> tests, int timeStep) {

    int n, m;
    int foundIndex;
    int patientNo;
    int noFacilities;
    int randInt;
    int noTransPatients = 0;
    //float mort;
    //float incid;
    int priority;
    int facilityReturnTime;
    int totNoInfected;
    int totNoNotInfected;
    int transitTime;
    int onsetToPresent;
    int diseaseListSize;
    int batchWaitTime = 1;
    int distIndex = 0;
    int regIndex = 0;
    float totPop;
    float totInfPop;
    float facInfPop;
    float totInfPopNotPresenting;
    float facInfPopNotPresenting;
    //float totNotInfPop;
    //float tmpIncidence = 0;
    float trans;
    float transThreshold;
    float randFloat;
    float rand;
    float distance;
    float perLostSamples = 0;
    float patientsRatioUninfInf = 1;
    float patientsRatioUninfInfCalc = 1;
    float prpDiseaseIncidence = 1;
    float totNoNotInfectedLocal;
    float addInfectedPatients = 0;
    float* popBins;
    bool success;
    bool infected;
    bool testingAvailable;
    bool transFlag;
    bool debugOn = false;
    bool debugOn1 = false;
    string diseaseOnListName;
    string diseaseName;
    string patientDiseaseName;
    string closestName;
    string testName;
    Patient* p;
    Sample* s;
    Diagnosis* d;
    Facility* f;
    Facility* testFacility;
    Facility* remoteTestFacility;
    Stats* stat = NULL;
    Stats* facilityStat = NULL;
    vector<facilityAttributes*> fa;

    // debugOn1 - true
    if (debugOn1) {
         std::cout << "inside create patients" << "\n";
    }

    // count no. of facilities
    noFacilities = fac.size();

    // population array with one slot for each facility    
    float popArray[noFacilities];
    float popInfArray[noFacilities];

    diseaseListSize = diseaseList.size();

    // now for each disease in that we are modeling, extract incidence to calculate no. of patients to create
    // loop through the list of diseases to create and get the chacteristics of that disease
    for (auto j = 0; j < diseaseListSize; j++) {

        // get disease name from list of diseases to watch
        diseaseOnListName = diseaseList[j];

        success = false;

        // default values
        //incid = 0;
        priority = 0;

        // loop through list of disease objects and find one that matches
        for (auto k = 0u; k < dis.size(); k++) {

            diseaseName = dis[k]->getName();

            // if disease found update the disease parameters
            if (diseaseOnListName == diseaseName) {

                success = true;
                patientDiseaseName = diseaseName;
                //mort = dis[k]->getMortality();
                trans = dis[k]->getTransmission();
                transThreshold = dis[k]->getTransThreshold();
                priority = dis[k]->getPriority();
                perLostSamples = dis[k]->getPerLostSamples();
                stat = dis[k]->getStatsPtr();
                facilityStat = dis[k]->getFacStatsPtr();
                patientsRatioUninfInf = dis[k]->getPatientsRatioUninfInf();
                onsetToPresent = dis[k]->getTimeOnsetToPresentation();
                transFlag = dis[k]->getTransFlag();
                addInfectedPatients = dis[k]->getAddInfPatients();

                // reset to zero for new timestep after getting value
                dis[k]->setAddInfPatients(0);
                break;
            }
        }

        // debugOn1 - true
        if (debugOn1) {
            std::cout << "inside create patients disease list name = " << diseaseOnListName << ", disease name = " << diseaseName << ", totalPopulation = " << totalPopulation << "\n";
            std::cout << "trans = " << trans << ", priority = " << priority << ", perLostSamples = " << perLostSamples << ", patientsRatioUninfInf = " << patientsRatioUninfInf << ", onsetToPresent = " << onsetToPresent << "\n";
            std::cout << "***********countSeqPopTB = " << countSeqPopTB << ", nextNoSeqPopTB = " << nextNoSeqPopTB << "\n";
        }

        // found disease - now create patients for that disease
        if (success) {
            // create an array of facility population vs facility incidence bins.
            // each popArray member is the total probabilities of the preceding facilities + the probability of this facility
            // it is determined by the population at this facility times the incidence at this facility
            // When you create a patient, you run a random number between zero and the total population of Ghana times the incidence of Ghana
            // whichever bin the number fall into tells you which facility it belongs to
            totPop = 0;
            totInfPop = 0;
            facInfPop = 0;
            totNoNotInfectedLocal = 0;
            totInfPopNotPresenting = 0;

            for (int i = 0; i < noFacilities; i++) {

                //prpDiseaseIncidence = fac[i]->getDiseaseIncidence(patientDiseaseName);
                totPop = totPop + fac[i]->getPopulation();
                facInfPop = fac[i]->getPopulation() * fac[i]->getDiseaseIncidence(patientDiseaseName);
                totInfPop = totInfPop + facInfPop;
                // only count those not presenting once during the year
                if (timeStep % timestepsPerYear == 0) {

                    //std::cout << "not reporting stats timestep - " << timeStep << " tot - " << totInfPopNotPresenting << "\n";
                    
                    facInfPopNotPresenting = fac[i]->getPopulation() * fac[i]->getDiseaseIncidenceNotPresenting(patientDiseaseName);
                    totInfPopNotPresenting = totInfPopNotPresenting + facInfPopNotPresenting;
                }
                totNoNotInfectedLocal = totNoNotInfectedLocal + (facInfPop * int(fac[i]->getDiseaseRatioUninfInf(patientDiseaseName)));
                
                //std::cout << " create patients facInfPop = " << facInfPop << ", totNoNotInfectedLocal = " << facInfPop * int(fac[i]->getDiseaseRatioUninfInf(patientDiseaseName)) << ", ratio = " << int(fac[i]->getDiseaseRatioUninfInf(patientDiseaseName)) << "\n";
                //std::cout << " create patients pop = " << fac[i]->getPopulation() << ", inc = " << fac[i]->getDiseaseIncidence(patientDiseaseName) << ", ratio = " << fac[i]->getDiseaseRatioUninfInf(patientDiseaseName) << "\n";
                //std::cout << " create patients pop = " << fac[i]->getPopulation() << ", inc = " << fac[i]->getDiseaseIncidence(patientDiseaseName) << "\n";
                //std::cout << " create patients facInfPopNotPresenting = " << facInfPopNotPresenting << ", totInfPopNotPresenting = " << totInfPopNotPresenting << ", facInfPop = " << facInfPop << ", totInfPop = " << totInfPop << "\n";

                popArray[i] = totPop;
                popInfArray[i] = totInfPop;
                //tmpIncidence = fac[i]->getDiseaseIncidence(patientDiseaseName);
                
                // debugOn - true
                if (debugOn) {
                    std::cout << "popArray i = " << i << ", facility = " << fac[i]->getName() << ", popArray[i] = " << popArray[i] << ", population = " << totPop << ", population infected = " << totInfPop;
                    std::cout << ", fac pop = " << fac[i]->getPopulation() << ", incid = " << fac[i]->getDiseaseIncidence(patientDiseaseName) << ", pat dis name = " << patientDiseaseName << "\n";
                }
            }

            // take into account the number of patients not infected not reporting
            totInfPopNotPresenting = totInfPopNotPresenting + totInfPopNotPresenting * patientsRatioUninfInf;

            // count patients that are infected but don't present
            if (statsCount) {

                stat->record_nPatientNotPresenting(0, totInfPopNotPresenting);
                //stat->record_nPatientNotPresenting(fac[i]->getDistrictIndex(), fac[i]->getRegionIndex(), totInfPopNotPresenting);
                //facilityStat->record_nPatientNotPresenting(fac[i]->getIDint(), totInfPopNotPresenting);
            }

            // debugOn - true
            if (debugOn) {

                std::cout << "popArray disease - " << patientDiseaseName << " - " << "\n";
                for (int i = 0; i < noFacilities; i++) {

                    std::cout << " i = " << i << ", facility = " << fac[i]->getName() << ", popInfArray[i] = " << popInfArray[i] << "\n";
                }
                std::cout << "\n";
                std::cout << "tot pop = " << totPop << ", totInfPop = " << totInfPop << ", inf/uninf ratio = " << int(fac[1]->getDiseaseRatioUninfInf(patientDiseaseName)) << "\n";
            }

            
            // recalculate the patients uninfected to infected ratio based on the ratio stored with each facility and number of infected patients
            // the ratio may be different depending on whether the reagion or district ratio is different from national average - region-district-specific-data.csv
            patientsRatioUninfInfCalc = totNoNotInfectedLocal / totInfPop;

            //std::cout << "***********after pop array building countSeqPopTB = " << countSeqPopTB << ", nextNoSeqPopTB = " << nextNoSeqPopTB << "\n";
            //std::cout << "***********after pop array building totInfPop = " << totInfPop << ", totNoNotInfectedLocal = " << totNoNotInfectedLocal << "\n";
            //std::cout << "***********after pop array building patientsRatioUninfInf = " << patientsRatioUninfInf << ", patientsRatioUninfInfCalc = " << patientsRatioUninfInfCalc << "\n";

            // seed random number generator
            //unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
            //std::mt19937 generator(seed);

            // need to multiply by 100 because totPop has been multiplied by incidence, which reduces it by 100
            //std::uniform_int_distribution<int> distribution(1, totPop * 100);

            // adjust no. of patients by number of years analysis is running
            // for Ghana assume a 1.022 growth rate every year - growth rate is handled in getPopulation in the facility object


            //if (false) {
            //    //totNoInfected = int(totInfPop);
            //    //totNoNotInfected = int(dis[k]->getPatientsRatioNonInfInf()) * totNoInfected;
            //    totNotInfPop = dis[k]->getPatientsRatioNonInfInf() * totInfPop;
            //    // 
            //    // debugOn1 - true
            //    if (debugOn1) {
            //        std::cout << "inside create patients totInf = " << totNoInfected << ", totnotinf = " << totNoNotInfected << ", totInfPop = " << totInfPop << ", poparray[max] = " << popArray[noFacilities - 1] << ", patientsRatioNonInfInf = " << dis[k]->getPatientsRatioNonInfInf() << "\n";
            //    }

            //    if (currentYearInRun > 0) {

            //        for (int i = 0; i < currentYearInRun; i++) {

            //            // multiply by growth rate for x number of years
            //            totInfPop = totInfPop * popGrowthRate;
            //            totNotInfPop = totNotInfPop * popGrowthRate;
            //        }
            //    }
            //    totNoInfected = int(totInfPop);
            //    totNoNotInfected = int(totNotInfPop);

            //    // keep track of extra to see if numbers add up
            //    debugCounter = debugCounter + (totInfPop - totNoInfected);
            //}
            //if (false) {

            //    totNoInfected = int(totInfPop);
            //    totNoNotInfected = int(patientsRatioUninfInf) * totNoInfected;

            //    // debugOn1 - true
            //    if (debugOn1) {
            //        std::cout << "inside create patients totInf = " << totNoInfected << ", totnotinf = " << totNoNotInfected << ", totInfPop = " << totInfPop << ", poparray[max] = " << popArray[noFacilities - 1] << ", patientsRatioNonInfInf = " << patientsRatioUninfInf << "\n";
            //    }

            //    if (currentYearInRun > 0) {

            //        for (int i = 0; i < currentYearInRun; i++) {

            //            // multiply by growth rate for x number of years
            //            totNoInfected = int(totNoInfected * popGrowthRate);
            //            totNoNotInfected = int(totNoNotInfected * popGrowthRate);
            //        }
            //    }
            //}

            totNoInfected = int(totInfPop);
            debugCounter = debugCounter + (totInfPop - totNoInfected);

            // keep track of roundoff error between steps
            // 
            // if there is less then 1 person remaining, keep track of it for next timestep
            // When that exceeds 1, add a new infected person and reduce the counter
            if (debugCounter >= 1) {

                totNoInfected = totNoInfected + 1;
                debugCounter = debugCounter - 1;
            }

            // adjust patientsRatioUninfInf in case ratio is different enough for a district or region from national average to skew the national average
            // this can be found in region-district-specific-data.csv
            //totNoNotInfected = int(patientsRatioUninfInf) * totNoInfected;
            totNoNotInfected = patientsRatioUninfInfCalc * totNoInfected;

            // adjust totNoNotInfected by the number of patients added due to disease transmission
            // the infected patients have already been added with a representation time of onsetToPresent
            if (transFlag) {

                totNoNotInfected = totNoNotInfected + (patientsRatioUninfInfCalc * addInfectedPatients);
            }

            //std::cout << "after population count disease = " << diseaseOnListName << ", totNoNotInfected = " << totNoNotInfected << ", patientsRatioUninfInf = " << patientsRatioUninfInf << ", totNoNotInfLocal = " << totNoNotInfectedLocal << "\n";
            //std::cout << "total inf pop = " << totInfPop << ", tot  pop = " << totPop << ", currentYearInRun = " << currentYearInRun << ", totNoInfected = " << totNoInfected << ", totNoNotInfected = " << totNoNotInfected << "\n";
            //std::cout << "total tot pop = " << totPop << ", totNoInfected = " << totNoInfected << ", totNoNotInfected = " << totNoNotInfected << ", totInfPop = " << totInfPop << ", inc = " << 100000*365*tmpIncidence << "\n";

            // debugOn - true - false
            if (debugOn) {
                std::cout << "inside create patients totInf = " << totNoInfected << ", totnotinf = " << totNoNotInfected << ", totInfPop = " << totInfPop << ", poparray[max] = " << popArray[noFacilities - 1] << ", popInfarray[max] = " << popInfArray[noFacilities - 1] << "\n";
                std::cout << " countSeqPopTB = " << countSeqPopTB << ", nextNoSeqPopTB = " << nextNoSeqPopTB << " patientsRatioUninfInf = " << patientsRatioUninfInf << ", prpDiseaseIncidence = " << prpDiseaseIncidence << "\n";
            }

            patientNo = 0;

            // create totNoInfected + notNoNotInfected patients
            if ((totNoInfected + totNoNotInfected) > 0) {

                do {
                    // generate number between 1 and total population count * incidence for this disease
                    randInt = getNextRandomNoPop(diseaseOnListName);

                    // find facility that corresponds with that population no.
                    infected = false;
                    foundIndex = 0;

                    //if (randInt % (int(dis[k]->getPatientsRatioNonInfInf()) + 1) == 0) {

                    //    // 1 out of (dis[k]->getPatientsRatioNoInfInf() + 1) is infected
                    //    infected = true;
                    //}
                    // first make the infected patients - then make the uninfected patients
                    if (patientNo < totNoInfected) {

                        infected = true;
                    }

                    // debugOn1 - true - false
                    if (debugOn1) {
                        std::cout << "inside create patients randint = " << randInt << ", infected = " << infected << ", fac size = " << noFacilities << ", m = " << foundIndex << ", popTb = " << popTB << "\n";
                    }

                    // create a random number - this maps to a population distribution (popArray) which will tell you which facility the patient will belong to
                    // foundIndex contains the index to the facility that will "own" the patient
                    m = -1;
                    randFloat = float(randInt) / 100;

                    // watch out for multiplication errors from incidence adjustment
                    if (randFloat > popInfArray[noFacilities - 1]) {

                        if (debugOn1) std::cout << "changed randFloat from " << randFloat << " to " << popInfArray[noFacilities - 1] << "\n";

                        randFloat = popInfArray[noFacilities - 1];
                    }

                    // loop through the popInfArray and find the array bin the random number fits in - this index will be foundIndex
                    // this maps to the facility to put the patient
                    do {

                        m = m + 1;
                        foundIndex = m;

                        // debugOn - true
                        if (debugOn) std::cout << "inside popArray loop randFloat = " << randFloat << ", m = " << m << ", popArray[m] = " << popArray[m] << ", popInfArray[m] = " << popInfArray[m] << ", noFac = " << noFacilities << "\n";

                        if (m >= noFacilities) {

                            // output error message - exceeded population bins in createPatients
                            std::cout << "***** exceeded population bins index in createPatients randint = " << randInt << ", randFloat = " << randFloat << ", infected = " << infected << ", fac size = " << noFacilities;
                            std::cout << ", m = " << foundIndex << ", popTb = " << popTB << ", popArray[m] = " << popArray[m] << ", popArray[m-1] = " << popArray[m - 1] << ", countSeqPopTB = " << countSeqPopTB << ", nextNoSeqPopTB = " << nextNoSeqPopTB << "\n";
                            for (int i = 0; i < noFacilities; i++) {

                                std::cout << "facility = " << fac[i]->getName() << ", i = " << i << ", popArray[i] = " << popArray[i] << ", popInfArray[i] = " << popInfArray[i] << "\n";
                            }
                        }
                    } while ((randFloat > popInfArray[m]) && (m < noFacilities));

                    // debugOn1 - true
                    if (debugOn1) {
                        std::cout << " after loop ******  randFloat = " << randFloat << " m = " << foundIndex << " poparray = " << popArray[foundIndex] << ", diag avail = " << fac[foundIndex]->diagnosisAvailable() << "\n";
                        std::cout << "inside create patients noFacilities = " << noFacilities << ", foundIndex = " << foundIndex << ", facility name = " << fac[foundIndex]->getName() << "\n" << std::flush;
                    }

                    //diseaseOnListName == "HIV"
                    if (debugOn1) {

                        if ((fac[foundIndex]->getName() != "Keta Municipal Hospital") && (fac[foundIndex]->getName() != "Sacred Heart (keta) Hospital")) {

                            std::cout << "facility foundIndex = " << foundIndex << ", m = " << m << ", facility name = " << fac[foundIndex]->getName() << ", randFloat = " << randFloat << ", popinfarray = " << popInfArray[m] <<"\n";
                            std::cout << "foundIndex = " << foundIndex << ", facility name0 = " << fac[foundIndex - 1]->getName() << ", popinfarray = " << popInfArray[m - 1] << ", facility name = " << fac[foundIndex]->getName() << ", popinfarray = " << popInfArray[m];
                            std::cout << ", facility name1 = " << fac[foundIndex+1]->getName() << ", popinfarray = " << popInfArray[foundIndex+1] << ", facility name2 = " << fac[foundIndex + 2]->getName() << ", popinfarray = " << popInfArray[foundIndex + 2] << "\n";
                        }
                    }

                    //std::cout << "after second do loop  foundIndex = " << foundIndex << " pop = " << fac[foundIndex]->getPopulation() <<"\n";

                    // don't create patients for facilites with empty catchments or that don't have diagnosis capabilities
                    if (fac[foundIndex]->getPopulation() > 1) {

                        // debugOn - true
                        if (debugOn)
                            std::cout << "inside getPopulation before make patient " << "\n";

                        if (fac[foundIndex]->diagnosisAvailable()) {

                            // debugOn - true
                            if (debugOn)
                                std::cout << "inside diagnosis available before make patient, total patients = " << totNoInfected + totNoNotInfected << "\n";

                            // make patient
                            // generate a random number between 0 and 1.  This will tell you which bin (and the corresponding distance/time) for each patient
                            randInt = getNextRandomNo100();

                            // debugOn - true
                            if (debugOn)
                                std::cout << "after getNextRandomNo100 randInt = " << randInt << "\n";

                            //rand = (float)randInt / (totPop * 100);
                            rand = (float)randInt / 100;

                            popBins = fac[foundIndex]->getPopBins();

                            // debugOn - true
                            if (debugOn)
                                std::cout << "randInt " << randInt << ", rand " << rand << ", popBins[0] " << popBins[0] << ", popBins[1] " << popBins[1] << ", popBins[2] " << popBins[2] << "\n";

                            // calculate distance from facility
                            n = -1;
                            do {
                                n++;
                                // std::cout << "popbins " << n << "," << popBins[n] << "\n";
                            } while (rand > popBins[n] && n < 9);

                            distance = (float)(n + 1) * fac[foundIndex]->getBinInc();

                            // debugOn - true
                            if (debugOn) {
                                std::cout << "patient distance " << distance << ", n = " << n << ", getbininc = " << fac[foundIndex]->getBinInc() << "\n";
                            }

                            // check to see if testing for this disease is done here - if so keep Patient
                            // otherwise send them home

                            // debugOn - true - false
                            if (debugOn) {
                                std::cout << "new patient testing facility = " << fac[foundIndex]->getName() << " for  " << patientDiseaseName << ", test avail =  " << fac[foundIndex]->testingAvailableAny(patientDiseaseName) << std::flush;
                            }

                            // no longer only check for Xpert test
                            testingAvailable = fac[foundIndex]->testingAvailableAny(patientDiseaseName);
                            testName = fac[foundIndex]->testingAvailableName(patientDiseaseName);

                            // debugOn - true
                            if (debugOn) {
                                std::cout << "testing available = " << testingAvailable << " testName =   " << testName << "\n";
                            }

                            // if (fac[foundIndex]->testingAvailable(patientDiseaseName,"Xpert")) {
                            if (testingAvailable) {

                                p = new Patient(fac[foundIndex]->getName(), fac[foundIndex]->getDistrict(), fac[foundIndex]->getDistrictIndex(), fac[foundIndex]->getRegion(), fac[foundIndex]->getRegionIndex(), patientDiseaseName, distance, n, infected, PatInUnTest, testName, timeStep);

                                //std::cout << "patient testing here facility =  " << fac[foundIndex]->getName() << ", dist = " << fac[foundIndex]->getDistrict();
                                //std::cout << ", dist index = " << fac[foundIndex]->getDistrictIndex() << ", reg = " << fac[foundIndex]->getRegion() <<  ", reg ind = " << fac[foundIndex]->getRegionIndex() << "\n";
                                
                                // check disease transmission for infected patients
                                if ((infected) && (transFlag)) {

                                    // check to see if patient has transmitted the disease to anyone else before coming in
                                    noTransPatients = checkTransPatients(fac[foundIndex], patientDiseaseName, p->getPopBinIndex(), transThreshold, onsetToPresent);

                                    createTransPatients(noTransPatients, list, fac[foundIndex]->getName(), dis, patientDiseaseName, tests, p->getPopBinIndex(), onsetToPresent);
                                }
                                
                                // patient already here - testing here - no return time
                                facilityReturnTime = 0;

                                // mark where sample is being tested
                                p->setSampleTestFacility(fac[foundIndex]->getName());

                                // debugOn - true - false
                                if (debugOn) {
                                    std::cout << "patient here, testing here facility =  " << fac[foundIndex]->getName() << ", return time = " << facilityReturnTime << "\n";
                                }
                            }
                            else {

                                // find nearest test facility and find the highest priority test for this disease that it does
                                remoteTestFacility = list->getPtr(fac[foundIndex]->getClosestNameByDisease(patientDiseaseName, fac[foundIndex]->getUpName()));
                                testName = remoteTestFacility->testingAvailableName(patientDiseaseName);

                                // debugOn - true
                                if (debugOn) {
                                    std::cout << "remote test facility = " << remoteTestFacility << " name = " << fac[foundIndex]->getName() << " testName = " << testName;
                                    std::cout << " patientDiseaseName = " << patientDiseaseName << " distance = " << distance << " infected = " << infected;
                                    std::cout << " distance = " << distance << " PatAwayUnTest = " << PatAwayUnTest << "\n";
                                }

                                p = new Patient(fac[foundIndex]->getName(), fac[foundIndex]->getDistrict(), fac[foundIndex]->getDistrictIndex(), fac[foundIndex]->getRegion(), fac[foundIndex]->getRegionIndex(), patientDiseaseName, distance, n, infected, PatAwayUnTest, testName, timeStep);

                                // check disease transmission for infected patients
                                if ((infected) && (transFlag)) {

                                    // check to see if patient has transmitted the disease to anyone else before coming in
                                    checkTransPatients(fac[foundIndex], patientDiseaseName, p->getPopBinIndex(), transThreshold, onsetToPresent);

                                    createTransPatients(noTransPatients, list, fac[foundIndex]->getName(), dis, patientDiseaseName, tests, p->getPopBinIndex(), onsetToPresent);
                                }
                                
                                // find out when patient should return to the facility for test results for this disease and store with patient
                                facilityReturnTime = fac[foundIndex]->getTestReturnTime((patientDiseaseName), testName);

                                // debugOn - true
                                if (debugOn) {
                                    std::cout << "patient remote testng facilityReturnTime = " << facilityReturnTime << ", district index = " << fac[foundIndex]->getDistrict() << ", " << fac[foundIndex]->getDistrictIndex() << "\n";
                                }

                                // mark where sample is being tested
                                p->setSampleTestFacility(remoteTestFacility->getName());

                                // debugOn - true - false
                                if (debugOn) {
                                    std::cout << "patient away, no testing here facility =  " << fac[foundIndex]->getName() << ", return time = ";
                                    std::cout << facilityReturnTime << ", remote facility = " << remoteTestFacility->getName() << ", test name = " << testName << "\n";
                                }
                            }

                            if (debugOn) std::cout << "new patient getIDint =  " << fac[foundIndex]->getIDint() << "\n";

                            // update facility id for patient
                            p->setFacilityID(fac[foundIndex]->getIDint());
                            p->setFacilityTier(fac[foundIndex]->getTier());

                            int temp = p->getFacilityID();
                            if (debugOn) std::cout << "new patient p->setFacilityID =  " << temp << ", tier = " << fac[foundIndex]->getTier() << "\n";

                            // find the region and district indices for stats counting
                            distIndex = p->getFacilityDistrictIndex();
                            regIndex = p->getFacilityRegionIndex();

                            // debugOn - true
                            if (debugOn) std::cout << "patient region district =  " << regIndex << ", " << distIndex << ", disease = " << p->getDisease() << ", facility = " << fac[foundIndex]->getName() << "\n";


                            // count patients new and infected
                            if (statsCount) {

                                stat->record_nPatient(distIndex, regIndex);
                                facilityStat->record_nPatient(fac[foundIndex]->getIDint());

                                if (infected) {

                                    stat->record_nPatientInf(distIndex, regIndex);
                                    facilityStat->record_nPatientInf(fac[foundIndex]->getIDint());
                                }

                                // debugOn
                                if (debugOn) std::cout << "patient stats stored in distIndex = " << distIndex << " district = " << stat->returnDistrict(distIndex) << " regIndex = " << regIndex << ", region = " << stat->returnRegion(regIndex) << "\n";
                            }

                            p->setFacilityReturnTime(facilityReturnTime);

                            if (debugOn) std::cout << "after creating patient facility Return time = " << facilityReturnTime << "\n";

                            // find out if this strain is or will become drug resistant - disease dependent
                            //randInt = distribution(generator);

                            //if (randInt < perDrugResistant) {
                            //    p->setDrugResistant(true);
                            //}
                            //else {
                            //    p->setDrugResistant(false);
                            //}

                            // add patient to patient container
                            d = fac[foundIndex]->getDiagnosisPtr();
                            d->storePatient(p);

                            // debugOn - true - false
                            if (debugOn) {

                                std::cout << "after adding patient to list " << "\n";

                                //std::cout << "create patient " << fac[foundIndex]->getName() << ", closest facility = " << fac[foundIndex]->getClosestName(patientDiseaseName, fac[foundIndex]->getName()) << ", closest distance = " << fac[foundIndex]->getClosestDistance() << ", infected = " << infected << "\n";
                            }

                            //std::cout << "create patient " << fac[foundIndex]->getName() << ", closest facility = " << fac[foundIndex]->getClosestNameByDisease(patientDiseaseName, fac[foundIndex]->getName()) << ", closest distance = ";
                            //std::cout << fac[foundIndex]->getClosestDistByDisease(patientDiseaseName, fac[foundIndex]->getName()) << ", disease name = " << patientDiseaseName << ", infected = " << infected << "\n";

                            // create samples for each of the Patients
                            //testingAvailable = fac[foundIndex]->testingAvailable(patientDiseaseName,"Xpert");
                            //testingAvailable = fac[foundIndex]->testingAvailableAny(patientDiseaseName);
                            //testName = fac[foundIndex]->testingAvailableName(patientDiseaseName);

                            if (testingAvailable) {

                                // testing done here - change closest testing facility to here and distance to 0
                                s = new Sample(p, fac[foundIndex]->getName(), fac[foundIndex]->getTier(), fac[foundIndex]->getRegion(), fac[foundIndex]->getDistrict(), fac[foundIndex]->getName(), 0, patientDiseaseName, infected, priority, perLostSamples);

                                // store pointer with patient
                                p->setSamplePtr(s);

                                // count samples done in-house
                                if (statsCount) {

                                    stat->record_nSamplesIn(distIndex, regIndex);
                                    facilityStat->record_nSamplesIn(fac[foundIndex]->getIDint());
                                    stat->record_sPatientWaitingIn(distIndex, regIndex);
                                    facilityStat->record_sPatientWaitingIn(fac[foundIndex]->getIDint());
                                    stat->record_sSampleWaitingForTestIn(distIndex, regIndex);
                                    facilityStat->record_sSampleWaitingForTestIn(fac[foundIndex]->getIDint());
                                }

                                // update Sample status to in-transit - calculate transit time by distance to travel for testing
                                transitTime = 0;

                                // update the sample to the current test available here
                                testName = fac[foundIndex]->getTestName(patientDiseaseName);
                                s->setTest(testName);

                                // find test pointer that matches disease and test
                                for (auto tp : tests) {

                                    if ((tp->getTestName() == testName) && (tp->getDiseaseName() == diseaseName)) {

                                        s->setTestPtr(tp);
                                    }
                                }

                                // debugOn - true - false
                                if (debugOn) std::cout << "inside cp sample here " << fac[foundIndex]->getName() << " for " << patientDiseaseName << " test fac name = " << fac[foundIndex]->getClosestNameByTest(patientDiseaseName, testName) << " distPerTimeStep = " << distancePerTimeStep << " transitTime = " << transitTime << " testing = " << testingAvailable << " test name = " << testName << "\n";
                            }
                            else {

                                // debugOn - true - false
                                if (debugOn) {

                                    fa = fac[foundIndex]->getFacilityAttributesPtr();

                                    for (auto facSpec : fa) {

                                        std::cout << "test = " << facSpec->testName << ", up connection =  " << facSpec->closetConnectionWithTesting;;
                                        std::cout << ", up connection =  " << fac[foundIndex]->getClosestNameByDisease(patientDiseaseName, fac[foundIndex]->getUpName()) << ", dist = " << fac[foundIndex]->getClosestDistByDisease(patientDiseaseName, fac[foundIndex]->getUpName()) << "\n";
                                    }
                                }


                                s = new Sample(p, fac[foundIndex]->getName(), fac[foundIndex]->getTier(), fac[foundIndex]->getRegion(), fac[foundIndex]->getDistrict(), fac[foundIndex]->getClosestNameByDisease(patientDiseaseName, fac[foundIndex]->getUpName()), fac[foundIndex]->getClosestDistByDisease(patientDiseaseName, fac[foundIndex]->getUpName()), patientDiseaseName, infected, priority, perLostSamples);

                                // store pointer with patient
                                p->setSamplePtr(s);


                                // update Sample status to in-transit - calculate transit time by distance to travel for testing
                                transitTime = (int)ceil(fac[foundIndex]->getClosestDistByDisease(patientDiseaseName, fac[foundIndex]->getUpName()) / distancePerTimeStep);

                                if (transitTime < 1) {

                                    // if testing isn't here make sure it takes at least one time step to transport it
                                    transitTime = 1;
                                }


                                // count samples done at another testing facility
                                if (statsCount) {

                                    stat->record_nSamplesOut(distIndex, regIndex);
                                    facilityStat->record_nSamplesOut(fac[foundIndex]->getIDint());
                                    stat->record_timeSampleTransport(transitTime, distIndex, regIndex);
                                    facilityStat->record_timeSampleTransport(transitTime, fac[foundIndex]->getIDint());
                                    stat->record_nTransported(distIndex, regIndex);
                                    facilityStat->record_nTransported(fac[foundIndex]->getIDint());
                                    stat->record_sPatientWaitingOut(distIndex, regIndex);
                                    facilityStat->record_sPatientWaitingOut(fac[foundIndex]->getIDint());
                                    stat->record_sSampleWaitingForTestOut(distIndex, regIndex);
                                    facilityStat->record_sSampleWaitingForTestOut(fac[foundIndex]->getIDint());
                                }

                                // update the sample to the current test available at the facility the sample is being sent to
                                testFacility = list->getPtr(fac[foundIndex]->getClosestNameByDisease(patientDiseaseName, fac[foundIndex]->getUpName()));

                                testName = testFacility->getTestName(patientDiseaseName);
                                s->setTest(testName);

                                // find test pointer that matches disease and test
                                for (auto tp : tests) {

                                    if ((tp->getTestName() == testName) && (tp->getDiseaseName() == diseaseName)) {

                                        s->setTestPtr(tp);
                                    }
                                }

                                // debugOn - true - false
                                if (debugOn) std::cout << "inside cp sample away " << fac[foundIndex]->getName() << " for " << patientDiseaseName << ", name = " << fac[foundIndex]->getUpName() << ", distPerTimeStep = " << distancePerTimeStep << " transitTime = " << transitTime << " testing = " << testingAvailable << " test name = " << testName << "\n";
                            }

                            // update batch wait time for sample based on Disease
                            // default to no batch time
                            batchWaitTime = fac[foundIndex]->getBatchWaitTime(patientDiseaseName);

                            // update batch wait time for sample based on Disease
                            s->setBatchWaitTime(batchWaitTime);

                            // update patient agent with sample pointer
                            //p->setSamplePtr(s);

                            // update Sample status to in-transit - calculate transit time by distance to travel for testing
                            //transitTime = (int)ceil(fac[foundIndex]->getClosestDistByDisease(patientDiseaseName, fac[foundIndex]->getName()) / distancePerTimeStep);

                            // debugOn - true - false
                            if (debugOn) std::cout << "inside create patient " << timeStep << " batchWaitTime = " << batchWaitTime << " transitTime = " << transitTime << " testing = " << testingAvailable << "\n";

                            // if 0 transit days, testing is available here
                            if (transitTime < 1) {
                                s->setStatus(SampCreatedUnTest);   // New - no transit already at testing station

                                s->setTransitTime(0);
                                s->setTransitTimeSave(0);

                                // set how long waiting in batch to 0
                                s->setBatchWaitTimeSave(0);
                            }
                            else {

                                // testing done at another Facility
                                // Check to see if must wait for batch sending - determine this by checking timeStep mod batch interval
                                // if no remainder, send sample  - otherwise hold it
                                if (debugOn) std::cout << "inside create patient before batch wait timestep " << timeStep << " batchWaitTime = " << batchWaitTime << "\n";

                                if ((batchWaitTime == 0) || (timeStep % batchWaitTime == 0)) {

                                    if (debugOn) std::cout << "inside create patient sending out sample " << "\n";

                                    // time to send out batch of samples
                                    s->setStatus(SampUnTestInTransit); // set status to in transit

                                    s->setTransitTime(transitTime);
                                    s->setTransitTimeSave(transitTime);

                                    // set how long waiting in batch to 0
                                    s->setBatchWaitTimeSave(0);
                                }
                                else {

                                    if (debugOn) std::cout << "inside create patient not yet hold sample " << "\n";

                                    // not yet, hold sample until next time steps
                                    s->setStatus(SampCreatedUnTestBatch); // set status to waiting for batch transit

                                    s->setTransitTime(transitTime);
                                    s->setTransitTimeSave(transitTime);

                                    // set how long waiting in batch to days left before sending out in batch mode
                                    s->setBatchWaitTimeSave(timeStep % batchWaitTime);
                                }
                            }

                            // note when sample was created
                            s->setCreateTime(timeStep);
                            p->setCreateTime(timeStep);
                            if (debugOn) std::cout << "inside create patient sample created =  " << timeStep << "\n";

                            // now add Sample to _testingFacility _sampleContainer
                            //f = facilitiesList->getPtr(fac[foundIndex]->getClosestName());
                            if (testingAvailable) {
                                closestName = fac[foundIndex]->getName();
                            }
                            else {
                                closestName = fac[foundIndex]->getClosestName(patientDiseaseName);
                                //closestName = fac[foundIndex]->getClosestNameByTest(patientDiseaseName, "Xpert");
                                //closestName = fac[foundIndex]->getClosestNameByDisease(patientDiseaseName, fac[foundIndex]->getName());
                            }

                            if (debugOn) {
                                std::cout << "facility = " << fac[foundIndex]->getName() << ", testing available = " << testingAvailable << ", transit time " << transitTime << ", closest name " << closestName << "\n";
                            }

                            //std::cout << "in create patients add sample to testing facility = " << closestName << ", orig-facility = " << fac[foundIndex]->getName() << "\n";
                            //f = fac[foundIndex]->getClosestPtr();
                            f = facilitiesList->getPtr(closestName);
                            if (debugOn) {
                                std::cout << "after getptr " << "\n";
                            }



                            if (f) {
                                f->addToSampleContainer(s);
                                //std::cout << "after add to sample " << "\n";
                            }
                            else {
                                std::cout << "couldn't find testing Facilty for new Sample " << fac[foundIndex]->getName() << ", " << "\n";
                            }

                            patientNo = patientNo + 1;
                            if (debugOn) {
                                std::cout << "patientNo =  " << patientNo << ", totPat = " << (totNoInfected + totNoNotInfected) << "\n";
                            }
                        }
                        //debugOn1 true false
                        if (debugOn1)
                            std::cout << "after facility population while loop " << "\n";
                    }
                    //debugOn1 true false
                    if (debugOn1)
                        std::cout << "bottom of while loop tot patients = " << (totNoInfected + totNoNotInfected) << " patient no =" << patientNo << "\n";

                } while (patientNo < (totNoInfected + totNoNotInfected));
            }  // don't create patients if totNoInfected + totNoNotInfected < 1

                                          
            //std::cout << "***********after m array  countSeqPopTB = " << countSeqPopTB << ", nextNoSeqPopTB = " << nextNoSeqPopTB << "\n";

            //debugOn1 true false
            if (debugOn1)
                std::cout << "after while loop " << "\n";
        }
        //debugOn1 true false
        if (debugOn1)
                std::cout << "after disease while loop " << diseaseOnListName << "\n";
    }

}


// see change run specific test and disease paramenters
void changeFiles(vector<vector<string>> runSpecific, vector<Disease*> disease, vector<Test*> test) {


    int index;
    int runSpecificSize;
    int lineSize;
    bool foundDisease;
    bool foundTest;
    bool debug = false;
    
    runSpecificSize = runSpecific.size();

    // go through each line and either modify or append to appropriate vector
    for (int i = 0; i < runSpecificSize; i++) {
        
        lineSize = runSpecific[i].size();
        
        if (DEBUG5) {
            std::cout << runSpecific[i][0] << ' ' << runSpecific[i][1] << ' ' << runSpecific[i][2] << '\n';
        }

        if (runSpecific[i][0] == "Disease") {

            // update specific disease parameters - error if we don't have that disease
            foundDisease = false;

            for (auto d : disease) {

                // update specific disease parameters - error if we don't have that disease
                if (d->getName() == runSpecific[i][1]) {

                    foundDisease = true;
                    index = 2;
                    if (DEBUG5) {
                        std::cout << "inside disease found disease = " << runSpecific[i][1] << '\n';
                    }

                    // loop through remaining items and change them for this disease
                    while (index < lineSize) {

                        if (DEBUG5) {
                            std::cout << "inside disease found attri = " << runSpecific[i][index] << " index = " << index << '\n';
                        }
                        
                        // now change attribute in disease
                        if (runSpecific[i][index] == "Mortality") {
                            d->setMortality(stof(runSpecific[i][index + 1]));

                            if (debug) std::cout << "Changed Mortality for " << runSpecific[i][1] << " to " << stof(runSpecific[i][index + 1]) << '\n';
                        }
                        else if (runSpecific[i][index] == "Incidence") {
                            d->setIncidence(stof(runSpecific[i][index + 1]));

                            if (debug) std::cout << "Changed Incidence for " << runSpecific[i][1] << " to " << stof(runSpecific[i][index + 1]) << '\n';
                        }
                        else if (runSpecific[i][index] == "IncAdjType") {
                            d->setIncAdjType(runSpecific[i][index + 1]);

                            if (debug) std::cout << "Changed incAdjType for " << runSpecific[i][1] << " to " << stof(runSpecific[i][index + 1]) << '\n';
                        }
                        else if (runSpecific[i][index] == "IncAdjFactor") {
                            d->setIncAdjFactor(stof(runSpecific[i][index + 1]));

                            if (debug) std::cout << "Changed IncAdjFactor for " << runSpecific[i][1] << " to " << stof(runSpecific[i][index + 1]) << '\n';
                        }
                        else if (runSpecific[i][index] == "PrpIncPresenting") {
                            d->setPrpIncPresenting(stof(runSpecific[i][index + 1]));

                            if (debug) std::cout << "Changed PrpIncPresenting for " << runSpecific[i][1] << " to " << stof(runSpecific[i][index + 1]) << '\n';
                        }
                        else if (runSpecific[i][index] == "PatRatioUninfInf") {
                            d->setPatientsRatioUninfInf(stof(runSpecific[i][index + 1]));

                            if (debug) std::cout << "Changed PatRatioUninfInf for " << runSpecific[i][1] << " to " << stof(runSpecific[i][index + 1]) << '\n';
                        }
                        else if (runSpecific[i][index] == "PerPatientPresentInf") {
                            d->setPerPatientPresentInf(stof(runSpecific[i][index + 1]));

                            if (debug) std::cout << "Changed PerPatientPresentInf for " << runSpecific[i][1] << " to " << stof(runSpecific[i][index + 1]) << '\n';
                        }
                        else if (runSpecific[i][index] == "Transmission") {
                            d->setTransmission(stof(runSpecific[i][index + 1]));

                            if (debug) std::cout << "Changed Transmission for " << runSpecific[i][1] << " to " << stof(runSpecific[i][index + 1]) << '\n';
                        }
                        else if (runSpecific[i][index] == "Priority") {
                            d->setPriority(stoi(runSpecific[i][index + 1]));

                            if (debug) std::cout << "Changed Priority for " << runSpecific[i][1] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                        }
                        else if (runSpecific[i][index] == "TreatedPatientsPercentage") {
                            d->setTreatedPercentage(stoi(runSpecific[i][index + 1]));

                            if (debug) std::cout << "Changed TreatedPatientsPercentage for " << runSpecific[i][1] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                        }
                        else if (runSpecific[i][index] == "InitTreatSuccess") {
                            d->setInitialTreatmentSuccessRate(stoi(runSpecific[i][index + 1]));

                            if (debug) std::cout << "Changed InitTreatSuccess for " << runSpecific[i][1] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                        }
                        else if (runSpecific[i][index] == "InitTreatDeath") {
                            d->setInitialTreatmentDeathRate(stof(runSpecific[i][index + 1]));

                            if (debug) std::cout << "Changed InitTreatDeath for " << runSpecific[i][1] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                        }
                        else if (runSpecific[i][index] == "InitTreatLtoF") {
                            d->setInitialTreatmentLossToFollow(stoi(runSpecific[i][index + 1]));

                            if (debug) std::cout << "Changed InitTreatLtoF for " << runSpecific[i][1] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                        }
                        else if (runSpecific[i][index] == "UntreatedDeathPer") {
                            d->setPerUntreatedDie(stoi(runSpecific[i][index + 1]));

                            if (debug) std::cout << "Changed UntreatedDeathPer for " << runSpecific[i][1] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                        }

                        index = index + 2;
                    }
                }
            }

            if (!foundDisease) {

                // error condition
                std::cout << "Unable to change run specific pararmenter " << runSpecific[i][0] << ' ' << runSpecific[i][1] << ' ' << runSpecific[i][2] << '\n';
            }
       

        }
        else if (runSpecific[i][0] == "Test") {

            // update specific test parameters - error if we don't have that test
            foundTest = false;

            for (auto t : test) {

                if (DEBUG5) {
                    std::cout << "inside test found test = " << runSpecific[i][1] << " disease = " << runSpecific[i][3] << '\n';
                }
                
                // update specific test parameters - error if we don't have that test
                if (t->getTestName() == runSpecific[i][1]) {

                    // need a disease match as well
                    if (t->getDiseaseName() == runSpecific[i][3]) {
                        foundTest = true;
                        index = 4;

                        while (index < lineSize) {

                            if (DEBUG5) {
                                std::cout << "inside test found attri = " << runSpecific[i][index] << " index = " << index << '\n';
                            }

                            // convert mortality and incidence to floats from strings
                            if (runSpecific[i][index] == "TestsPerMachine") {
                                t->setTestsPerMachine(stoi(runSpecific[i][index + 1]));

                                if (debug) std::cout << "Changed TestsPerMachine for " << runSpecific[i][1] << " for " << runSpecific[i][3] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                            }
                            else if (runSpecific[i][index] == "CyclesPerTimestep") {
                                t->setCyclesPerTimestep(stoi(runSpecific[i][index + 1]));

                                if (debug) std::cout << "Changed CyclesPerTimestep for " << runSpecific[i][1] << " for " << runSpecific[i][3] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                            }
                            else if (runSpecific[i][index] == "MaxTestPerCycle") {
                                t->setMaxTestPerCycle(stoi(runSpecific[i][index + 1]));

                                if (debug) std::cout << "Changed MaxTestPerCycle for " << runSpecific[i][1] << " for " << runSpecific[i][3] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                            }
                            else if (runSpecific[i][index] == "ReagentCycle") {
                                t->setReagentCycle(stoi(runSpecific[i][index + 1]));

                                if (debug) std::cout << "Changed ReagentCycle for " << runSpecific[i][1] << " for " << runSpecific[i][3] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                            }
                            else if (runSpecific[i][index] == "Priority") {
                                t->setPriority(stoi(runSpecific[i][index + 1]));

                                if (debug) std::cout << "Changed Priority for " << runSpecific[i][1] << " for " << runSpecific[i][3] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                            }
                            else if (runSpecific[i][index] == "Sensitivity") {
                                t->setSense(stoi(runSpecific[i][index + 1]));

                                if (debug) std::cout << "Changed Sensitivity for " << runSpecific[i][1] << " for " << runSpecific[i][3] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                            }
                            else if (runSpecific[i][index] == "Specificity") {
                                t->setSpecif(stoi(runSpecific[i][index + 1]));

                                if (debug) std::cout << "Changed Specificity for " << runSpecific[i][1] << " for " << runSpecific[i][3] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                            }
                            else if (runSpecific[i][index] == "SensitivityMD") {
                                t->setSenseMD(stoi(runSpecific[i][index + 1]));

                                if (debug) std::cout << "Changed SensitivityMD for " << runSpecific[i][1] << " for " << runSpecific[i][3] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                            }
                            else if (runSpecific[i][index] == "SpecificityMD") {
                                t->setSpecifMD(stoi(runSpecific[i][index + 1]));

                                if (debug) std::cout << "Changed SpecificityMD for " << runSpecific[i][1] << " for " << runSpecific[i][3] << " to " << stoi(runSpecific[i][index + 1]) << '\n';
                            }

                            index = index + 2;
                        }
                    }
                }
            }

            if (!foundTest) {

                // error condition
                std::cout << "Unable to change run specific pararmenter " << runSpecific[i][0] << ' ' << runSpecific[i][1] << ' ' << runSpecific[i][2] << '\n';
            }
        }

    }

}


// change Xpert locations to match current facilitySpecific settings for TB and Xpert
void changeXpert(FacilitiesList* list, vector<vector<string>> facilitySpecific) {

    int facNo;
    string facName;
    bool Xpert = false;
    bool debug = false;


    if (debug) std::cout << "inside update stat xpert " << '\n';

    facNo = facilitySpecific.size();
    
    vector<Facility*> facilities = list->getListPtr();

    for (int i = 1; i < facNo; i++) {

        facName = facilitySpecific[i][1];
        
        if ((facilitySpecific[i][3] == "TB") && (facilitySpecific[i][7] == "Xpert")) {

            if (stoi(facilitySpecific[i][8]) == 1) {

                Xpert = true;
            }
            else {

                Xpert = false;
            }
        }

        // loop through each facility and if find match, update Xpert status
        for (auto facility : facilities) {

            if (facName == facility->getName()) {

                if (debug) std::cout << "inside update changeXpert facName = " << facName << " faclist name = " << facility->getName() << " xpert = " << Xpert << '\n';
                
                facility->setTestingAvailable("TB", "Xpert", Xpert);
                    
                facility->setXpert(Xpert);

            }
        }
    }

    if (debug) std::cout << "leaving update changeXpert" << '\n';

    return;
}


// create Region objects from input file
vector<Region*> createRegionObjects(string regionDistrictArray[]) {

    // loop through region/district list and create a region object for each region
    bool debug = false;

    std::vector<Region*> regions;

    if (debug) std::cout << "inside create regions " << '\n';

    // skip the first row, it contains column headers
    for (int i = 1; i < 17; i++) {

        regions.push_back(new Region(regionDistrictArray[i], i, 0));

        if (debug) std::cout << "inside create regions after create regions " << '\n';
    }

    return regions;
}


// create District objects from input file
vector<District*> createDistrictObjects(string regionDistrictArray[]) {

    // loop through region/district list and create a region object for each region
    bool debug = false;

    std::vector<District*> districts;

    if (debug) std::cout << "inside create districts " << '\n';

    // skip the first row, it contains column headers
    for (int i = 17; i < 277; i++) {

        districts.push_back(new District(regionDistrictArray[i], i - 16, 0));

        if (debug) std::cout << "inside create districts after create districts " << '\n';
    }

    return districts;
}

// update region and district objects and fill in data from facilities list
void updateRegionAndDistrictsFromFacilities(FacilitiesList* list, vector<District*> dist, vector<Region*> reg) {

    // loop through facilities and update populations for regions and districts
    int yearNo = 0;
    string regName;
    string distName;
    bool debug = false;
    vector<facilityAttributes*> facAttr;

    vector<Facility*> facilities = list->getListPtr();

    if (debug) std::cout << "inside update region and district populations " << '\n';
    
    for (auto facility : facilities) {

        regName = facility->getRegion();
        distName = facility->getDistrict();

        // convert them both to upper case if not in that format
        for (size_t i = 0; i < regName.size(); i++)
  	    {
  		    regName[i] = toupper(regName[i]);
  	    }
        for (size_t i = 0; i < distName.size(); i++)
  	    {
  		    distName[i] = toupper(distName[i]);
  	    }

        if (debug) std::cout << "inside update region and district populations fac name = " << facility->getName() << ", reg = " << regName << ", dist = " << distName  << ", pop = " << facility->getPopulation()  << '\n';

        // add population counts and incidence to region objects from FacilitiesList
        for (auto r : reg) {
           
            if (r->getName() == regName) {
           
                r->incrementPopulation(facility->getPopulation());
                r->setTBIncidence(facility->getIncidence("TB", yearNo)*100000*365);
                r->setTBIncAdjFactor(facility->getIncAdjFactor("TB"));
                r->setTBPrpIncidencePresenting(facility->getPrpIncidencePresenting("TB"));
                r->setHIVIncidence(facility->getIncidence("HIV", yearNo) * 100000 * 365);
                r->setHIVIncAdjFactor(facility->getIncAdjFactor("HIV"));
                r->setHIVPrpIncidencePresenting(facility->getPrpIncidencePresenting("HIV"));
                r->setHCVIncidence(facility->getIncidence("HCV", yearNo) * 100000 * 365);
                r->setHCVIncAdjFactor(facility->getIncAdjFactor("HCV"));
                r->setHCVPrpIncidencePresenting(facility->getPrpIncidencePresenting("HCV"));
                r->setYFIncidence(facility->getIncidence("Yellow Fever", yearNo) * 100000 * 365);
                r->setYFIncAdjFactor(facility->getIncAdjFactor("Yellow Fever"));
                r->setYFPrpIncidencePresenting(facility->getPrpIncidencePresenting("Yellow Fever"));
                r->setMenIncidence(facility->getIncidence("Meningitis", yearNo) * 100000 * 365);
                r->setMenIncAdjFactor(facility->getIncAdjFactor("Meningitis"));
                r->setMenPrpIncidencePresenting(facility->getPrpIncidencePresenting("Meningitis"));
                r->setMeaIncidence(facility->getIncidence("Measles", yearNo) * 100000 * 365);
                r->setMeaIncAdjFactor(facility->getIncAdjFactor("Measles"));
                r->setMeaPrpIncidencePresenting(facility->getPrpIncidencePresenting("Measles"));
                r->setDis1Incidence(facility->getIncidence("Disease1", yearNo) * 100000 * 365);
                r->setDis1IncAdjFactor(facility->getIncAdjFactor("Disease1"));
                r->setDis1PrpIncidencePresenting(facility->getPrpIncidencePresenting("Disease1"));
                r->setDis2Incidence(facility->getIncidence("Disease2", yearNo) * 100000 * 365);
                r->setDis2IncAdjFactor(facility->getIncAdjFactor("Disease2"));
                r->setDis2PrpIncidencePresenting(facility->getPrpIncidencePresenting("Disease2"));

                //debug - true
                if (debug) std::cout << "inside update regionpopulations fac name = " << facility->getName() << ", reg = " << regName << ", pop = " << facility->getPopulation()  << ", inc = " << facility->getIncidence("TB", yearNo) * 100000 * 365 << '\n';

                break;
            }
        }

        // add population counts, incidence and regions to district objects from FacilitiesList
        for (auto d : dist) {
           
            if (d->getName() == distName) {
           
                d->incrementPopulation(facility->getPopulation());
                d->setRegionName(facility->getRegion());
                d->setRegionID(facility->getRegionIndex());
                d->setTBIncidence(facility->getIncidence("TB", yearNo) * 100000 * 365);
                d->setTBIncAdjFactor(facility->getIncAdjFactor("TB"));
                d->setTBPrpIncidencePresenting(facility->getPrpIncidencePresenting("TB"));
                d->setHIVIncidence(facility->getIncidence("HIV", yearNo) * 100000 * 365);
                d->setHIVIncAdjFactor(facility->getIncAdjFactor("HIV"));
                d->setHIVPrpIncidencePresenting(facility->getPrpIncidencePresenting("HIV"));
                d->setHCVIncidence(facility->getIncidence("HCV", yearNo) * 100000 * 365);
                d->setHCVIncAdjFactor(facility->getIncAdjFactor("HCV"));
                d->setHCVPrpIncidencePresenting(facility->getPrpIncidencePresenting("HCV"));
                d->setYFIncidence(facility->getIncidence("Yellow Fever", yearNo) * 100000 * 365);
                d->setYFIncAdjFactor(facility->getIncAdjFactor("Yellow Fever"));
                d->setYFPrpIncidencePresenting(facility->getPrpIncidencePresenting("Yellow Fever"));
                d->setMenIncidence(facility->getIncidence("Meningitis", yearNo) * 100000 * 365);
                d->setMenIncAdjFactor(facility->getIncAdjFactor("Meningitis"));
                d->setMenPrpIncidencePresenting(facility->getPrpIncidencePresenting("Meningitis"));
                d->setMeaIncidence(facility->getIncidence("Measles", yearNo) * 100000 * 365);
                d->setMeaIncAdjFactor(facility->getIncAdjFactor("Measles"));
                d->setMeaPrpIncidencePresenting(facility->getPrpIncidencePresenting("Measles"));
                d->setDis1Incidence(facility->getIncidence("Disease1", yearNo) * 100000 * 365);
                d->setDis1IncAdjFactor(facility->getIncAdjFactor("Disease1"));
                d->setDis1PrpIncidencePresenting(facility->getPrpIncidencePresenting("Disease1"));
                d->setDis2Incidence(facility->getIncidence("Disease2", yearNo) * 100000 * 365);
                d->setDis2IncAdjFactor(facility->getIncAdjFactor("Disease2"));
                d->setDis2PrpIncidencePresenting(facility->getPrpIncidencePresenting("Disease2"));

                if (debug) std::cout << "inside update district fac name = " << facility->getName() << ", dist = " << distName << ", pop = " << facility->getPopulation()  << ", inc = " << facility->getIncidence("TB", yearNo)  << '\n';

                break;
            }
        }
    }

    if (debug) {
    
        // add population counts to region objects from FacilitiesList
        for (auto r : reg) {

            if (r->getPopulation()  == 0) {
            
                std::cout << "region = " << r->getName() << ", pop = " << r->getPopulation() << '\n';
            }
        }

        // add population counts and regions to district objects from FacilitiesList
        for (auto d : dist) {
            
            if (d->getPopulation()  == 0) {

                std::cout << "district = " << d->getName() << ", pop = " << d->getPopulation() << '\n';
            }
        }
    }

return;
}


// get population values for regions and districts and update the disease stat variables
void updateStatsPopulation(vector<Region*> reg, vector<District*> dist, Stats* statPtr, int yearNo) {


    int totalPopulation;
    int population = 0;
    int startIndex = 0;
    int endIndex = 0;
    float growthRate = 1;
    bool debug = false;
    
    totalPopulation = 0;
            
    if (debug) std::cout << "inside update stat populations " << '\n';

    // create a growth rate for all the years that the ABM has run
    startIndex = referenceYear - 2015;
    endIndex = startIndex + yearNo;
    for (int i = startIndex; i < endIndex; i++) {
    
        growthRate = growthRate * popGrowthRateArray[i][1];
    }

    if (debug) std::cout << "inside update stat populations growth rate = " << growthRate << '\n';

    // update the stats population variable for both regions and districts
    //std::cout << "inside update stats population growth rate " << growthRate << '\n';

    // update stats population variables for regions
    for (auto r : reg) {

        population = int(r->getPopulation() * growthRate);
        
        statPtr->record_population(population, r->getID());

        totalPopulation = totalPopulation + population;

        // debug - true
        if (debug) std::cout << "inside update stats population region = " << r->getName() << ", population = " << r->getPopulation()  <<  ", id = " <<  r->getID() << '\n';
    }

    // update stats population variables for districts
    for (auto d : dist) {

        population = int(d->getPopulation() * growthRate);
        
        statPtr->record_population(population, d->getID()+16);

        if (debug) std::cout << "inside update stats population district = " << d->getName() << ", population = " << d->getPopulation()  <<  ", id = " <<  d->getID()+16 << '\n';
    }

    // save away national total Population
    statPtr->record_population(totalPopulation, 0);

    if (debug) std::cout << "inside update stats population total population =  " << totalPopulation << '\n';

    return;
}



// get values values for regions and districts and update the disease stat variables
void updateStatsIncidence(vector<Region*> reg, vector<District*> dist, Stats* statPtr, string disease, int yearNo) {

    float incidence = 0;
    bool debug = false;
            
   if (debug) std::cout << "inside update stat incidence " << '\n';

   // update the stats incidence variable for both regions and districts

   // update stats incidence variables for regions - convert incidence from per person per day to yearly/100,000
   for (auto r : reg) {

       if (disease == "TB") {
           //incidence = r->getIncidence() * 365 * 100000;
           incidence = r->getTBIncidence();

           // adjust back to original incidence and change by yearly incidence factor
           incidence = incidence * r->getTBPrpIncidencePresenting();
           incidence = incidence * (1 + r->getTBIncAdjFactor() * (yearNo - 1));
       }
       else if (disease == "HIV") {
           //incidence = r->getIncidence() * 365 * 100000;
           incidence = r->getHIVIncidence();

           // adjust back to original incidence and change by yearly incidence factor
           incidence = incidence * r->getHIVPrpIncidencePresenting();
           incidence = incidence * (1 + r->getHIVIncAdjFactor() * (yearNo - 1));
       }
       else if (disease == "HCV") {
           //incidence = r->getIncidence() * 365 * 100000;
           incidence = r->getHCVIncidence();

           // adjust back to original incidence and change by yearly incidence factor
           incidence = incidence * r->getHCVPrpIncidencePresenting();
           incidence = incidence * (1 + r->getHCVIncAdjFactor() * (yearNo - 1));
       }
       else if (disease == "Yellow Fever") {
           //incidence = r->getIncidence() * 365 * 100000;
           incidence = r->getYFIncidence();

           // adjust back to original incidence and change by yearly incidence factor
           incidence = incidence * r->getYFPrpIncidencePresenting();
           incidence = incidence * (1 + r->getYFIncAdjFactor() * (yearNo - 1));
       }
       else if (disease == "Meningitis") {
           //incidence = r->getIncidence() * 365 * 100000;
           incidence = r->getMenIncidence();

           // adjust back to original incidence and change by yearly incidence factor
           incidence = incidence * r->getMenPrpIncidencePresenting();
           incidence = incidence * (1 + r->getMenIncAdjFactor() * (yearNo - 1));
       }
       else if (disease == "Measles") {
           //incidence = r->getIncidence() * 365 * 100000;
           incidence = r->getMeaIncidence();

           // adjust back to original incidence and change by yearly incidence factor
           incidence = incidence * r->getMeaPrpIncidencePresenting();
           incidence = incidence * (1 + r->getMeaIncAdjFactor() * (yearNo - 1));
       }
       else if (disease == "Disease1") {
           //incidence = r->getIncidence() * 365 * 100000;
           incidence = r->getDis1Incidence();

           // adjust back to original incidence and change by yearly incidence factor
           incidence = incidence * r->getDis1PrpIncidencePresenting();
           incidence = incidence * (1 + r->getDis1IncAdjFactor() * (yearNo - 1));
       }
       else if (disease == "Disease2") {
           //incidence = r->getIncidence() * 365 * 100000;
           incidence = r->getDis2Incidence();

           // adjust back to original incidence and change by yearly incidence factor
           incidence = incidence * r->getDis2PrpIncidencePresenting();
           incidence = incidence * (1 + r->getDis2IncAdjFactor() * (yearNo - 1));
       }

       statPtr->record_incidence(incidence, r->getID());

        // debug - true
        if (debug) std::cout << "inside update stats incidence region = " << r->getName() << ", incidence = " << incidence <<  ", id = " <<  r->getID() << '\n';
   }

    // update stats incidence variables for districts - convert incidence from per person per day to yearly/100,000
    for (auto d : dist) {

        //incidence = d->getIncidence() * 365 * 100000;
        if (disease == "TB") {

            incidence = d->getTBIncidence();

            // adjust back to original incidence and change by yearly incidence factor
            incidence = incidence * d->getTBPrpIncidencePresenting();
            incidence = incidence * (1 + d->getTBIncAdjFactor() * (yearNo - 1));
        }
        else if (disease == "HIV") {

            incidence = d->getHIVIncidence();

            // adjust back to original incidence and change by yearly incidence factor
            incidence = incidence * d->getHIVPrpIncidencePresenting();
            incidence = incidence * (1 + d->getHIVIncAdjFactor() * (yearNo - 1));
        }
        else if (disease == "HCV") {

            incidence = d->getHCVIncidence();

            // adjust back to original incidence and change by yearly incidence factor
            incidence = incidence * d->getHCVPrpIncidencePresenting();
            incidence = incidence * (1 + d->getHCVIncAdjFactor() * (yearNo - 1));
        }
        else if (disease == "Yellow Fever") {

            incidence = d->getYFIncidence();

            // adjust back to original incidence and change by yearly incidence factor
            incidence = incidence * d->getYFPrpIncidencePresenting();
            incidence = incidence * (1 + d->getYFIncAdjFactor() * (yearNo - 1));
        }
        else if (disease == "Meningitis") {

            incidence = d->getMenIncidence();

            // adjust back to original incidence and change by yearly incidence factor
            incidence = incidence * d->getMenPrpIncidencePresenting();
            incidence = incidence * (1 + d->getMenIncAdjFactor() * (yearNo - 1));
        }
        else if (disease == "Measles") {

            incidence = d->getMeaIncidence();

            // adjust back to original incidence and change by yearly incidence factor
            incidence = incidence * d->getMeaPrpIncidencePresenting();
            incidence = incidence * (1 + d->getMeaIncAdjFactor() * (yearNo - 1));
        }
        else if (disease == "Disease1") {

            incidence = d->getDis1Incidence();

            // adjust back to original incidence and change by yearly incidence factor
            incidence = incidence * d->getDis1PrpIncidencePresenting();
            incidence = incidence * (1 + d->getDis1IncAdjFactor() * (yearNo - 1));
        }
        else if (disease == "Disease2") {

            incidence = d->getDis2Incidence();

            // adjust back to original incidence and change by yearly incidence factor
            incidence = incidence * d->getDis2PrpIncidencePresenting();
            incidence = incidence * (1 + d->getDis2IncAdjFactor() * (yearNo - 1));
        }

        statPtr->record_incidence(incidence, d->getID()+16);

        if (debug) std::cout << "inside update stats incidence district = " << d->getName() << ", incidence = " << incidence << ", id = " <<  d->getID()+16 << '\n';
    }

    if (debug) std::cout << "leaving update stats incidence" << '\n';

    return;
}




// get Xpert machine locations for regions and districts and update the disease stat variables
void updateStatsXpert(vector<Region*> reg, vector<District*> dist, Stats* statPtr, FacilitiesList* list) {

    string region;
    string district;
    bool xpertHere = false;
    bool debug = false;
    bool updateTotal = true;

    if (debug) std::cout << "inside update stat xpert " << '\n';

    vector<Facility*> facilities = list->getListPtr();

    // loop through each facility and extract resouce numbers for each test (for each disease) that is done there
    for (auto facility : facilities) {

        //xpertHere = facility->getXpert();
        xpertHere = facility->testingAvailable("TB","Xpert");
        region = facility->getRegion();
        district = facility->getDistrict();

        // update the stats xpert variable for both regions and districts

        // update stats xpert variables for regions
        for (auto r : reg) {

            if (r->getName() == region) {

                if (xpertHere) {
                    
                    
                    // update region count of Xpert machines
                    statPtr->record_xpertMach(r->getID());

                    // update total no. of Xpert machines
                    statPtr->record_xpertMachTotal();

                    updateTotal = false;
                }

                // debug - true
                if (debug) std::cout << "inside update stats xpert region = " << r->getName() << ", xpert = " << xpertHere << '\n';
            }
        }

        // update stats xpert variables for districts
        for (auto d : dist) {

            if (d->getName() == district) {

                if (xpertHere) {
                    
                    // update district count of Xpert machines
                    statPtr->record_xpertMach(d->getID() + 16);
                    
                    // only update total once
                    if (updateTotal) statPtr->record_xpertMachTotal();

                    updateTotal = false;
                }

                if (debug) std::cout << "inside update stats xpert district = " << d->getName() << ", xpert = " << xpertHere << '\n';
            }
        }
    }

    if (debug) std::cout << "leaving update stats xpert" << '\n';

    return;
}


// find out how many patients will be created by transmission for disease and where they will be located
int checkTransPatients(Facility* fac, string disease, int popBinsIndex, float transThreshold, int noTimesteps) {

    int noPatients = 0;
    float transProb = 0;
    float density = 0;
    float probPatient = 0;
    bool debug = false;
    vector<facilityAttributes*> facAttr;

    
    // debug - true
    if (debug) std::cout << "inside createTransPatients for disease = " << disease << '\n';

    facAttr = fac->getFacilityAttributesPtr();;

    for (auto a : facAttr) {

        if (a->disease == disease) {

            transProb = a->transmission;

            if (debug) std::cout << "facattr disease = " << a->disease << ", test = " << a->testName << ", testing = " << a->testing << ", transmission = " << transProb << '\n';

            break;
        }
    }
    
    // figure out how many new patients and where they are by probability of transmission, density of population and number of timesteps
    // Number of secondary cases = r0 x average duration of infectiousness x contact rate x transmission probability

    density = fac->getLocalDensity(popBinsIndex);
    
    probPatient = (density/10000) * transProb * noTimesteps;

    //debug - true
    if (debug) std::cout << "probPatient = " << probPatient << ", density = " << density << ", transProb = " << transProb << ", noTimesteps = " << noTimesteps << ", popBinsIndex = " << popBinsIndex << '\n';
    
    if (probPatient > transThreshold) {

        // make a patient
        noPatients = 1;
        
        //createTransPatient(fac, disease, popBinsIndex, noTimesteps);

        if (debug) std::cout << "inside createTransPatients create patient 1 at " <<  fac->getName() <<  '\n';
    }
    if (probPatient > (transThreshold*2)) {

        // make another patient
        noPatients = 2;
        
        //createTransPatient(fac, disease, popBinsIndex, noTimesteps);

        if (debug) std::cout << "inside createTransPatients create patient 2 at " << fac->getName() << '\n';
    }
    if (probPatient > (transThreshold*3)) {

        // make another patient
        noPatients = 3;

        // createTransPatient(fac, disease, popBinsIndex, noTimesteps);

        if (debug) std::cout << "inside createTransPatients create patient 3 at " << fac->getName() << '\n';
    }

    if (debug) std::cout << "leaving createTransPatients" << '\n';

    return noPatients;
}



//create a patient with this facility as epicenter - distance from facility is exponential to random number
void createTransPatients(int noPatients, FacilitiesList* list, string facility, vector<Disease*> diseaseList, string disease, vector<Test*> tests, int popBinsIndex, int noTimesteps) {

    int randInt = 0;
    int incTimestep = 0;
    string facName;
    bool debug = false;
    Patient* p = NULL;
    Facility* fac;
    vector<Facility *> latteralFacility;

    vector<facilityAttributes*> facAttr;

    if (debug) std::cout << "inside createTransPatient no. patients = " << noPatients << '\n';

    // no patients to make, leave
    if (noPatients < 1) return;

    // get current facility pointer
    fac = list->getPtr(facility);

    facAttr = fac->getFacilityAttributesPtr();

    for (int i = 1; i <= noPatients; i++) {

        randInt = getNextRandomNo100();

        // first figure out when relative to current time step
        incTimestep = float(randInt / 100) * noTimesteps;

        randInt = getNextRandomNo100();

        // now figure out where
        if (debug) std::cout << " created transmission patient randInt " << randInt << " noPatients " << noPatients << '\n';

        // most likely withing same facility reporting area
        if (randInt < 95) {

            // create patient here
            p = createPatient(list, facility, diseaseList, disease, tests, timeStep + incTimestep);

            p->setFromTransmission();

            if (debug) std::cout << "created transmission patient at " << facility << " patient no. " << i << " out of " << noPatients << '\n';
        }
        else {

            // otherwise create patient within lateral other facility
            // get list of latterals
            latteralFacility = fac->getLatPtr();

            // debug - true
            if (debug) std::cout << "trying to create transmission patient at " << facName << " instead of " << facility << '\n';

            randInt = getNextRandomNo100();
            // grab one at random
            for (auto f : latteralFacility) {

                // grab the last one for now
                facName = f->getName();
            }

            p = createPatient(list, facName, diseaseList, disease, tests, timeStep + incTimestep);

            p->setFromTransmission();

            // debug - true
            if (debug) std::cout << "created transmission patient at " << facName << " instead of " << facility << " patient no. " << i << " out of " << noPatients << '\n';
        }
    }

    if (debug) std::cout << "leaving createTransPatient incTimestep = " << incTimestep << '\n';

    return;
}

